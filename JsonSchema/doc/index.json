{
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation | Json Schema",
    "keywords": "API Documentation The API documentation is auto-generated from both source code and source code comments. For broader understandings, exploring the source code itself often reveals even more valuable insights and details. To access and explore the source code, please visit the GitHub repository here."
  },
  "api/RelogicLabs.JsonSchema.Collections.html": {
    "href": "api/RelogicLabs.JsonSchema.Collections.html",
    "title": "Namespace RelogicLabs.JsonSchema.Collections | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Collections Classes IndexHashMap<TK, TV> Interfaces IIndexMap<TK, TV> IKeyer<TK>"
  },
  "api/RelogicLabs.JsonSchema.Collections.IIndexMap-2.html": {
    "href": "api/RelogicLabs.JsonSchema.Collections.IIndexMap-2.html",
    "title": "Interface IIndexMap<TK, TV> | Json Schema",
    "keywords": "Interface IIndexMap<TK, TV> Namespace RelogicLabs.JsonSchema.Collections Assembly RelogicLabs.JsonSchema.dll public interface IIndexMap<TK, TV> : IList<TV>, ICollection<TV>, IEnumerable<TV>, IEnumerable where TK : notnull where TV : IKeyer<TK> Type Parameters TK TV Inherited Members IList<TV>.IndexOf(TV) IList<TV>.Insert(int, TV) IList<TV>.RemoveAt(int) IList<TV>.this[int] ICollection<TV>.Add(TV) ICollection<TV>.Clear() ICollection<TV>.Contains(TV) ICollection<TV>.CopyTo(TV[], int) ICollection<TV>.Remove(TV) ICollection<TV>.Count ICollection<TV>.IsReadOnly IEnumerable<TV>.GetEnumerator() Properties this[TK] TV this[TK key] { get; } Parameters key TK Property Value TV Keys IEnumerable<TK> Keys { get; } Property Value IEnumerable<TK> Values IEnumerable<TV> Values { get; } Property Value IEnumerable<TV> Methods AsReadOnly() IIndexMap<TK, TV> AsReadOnly() Returns IIndexMap<TK, TV> TryGetValue(TK, out TV?) bool TryGetValue(TK key, out TV? value) Parameters key TK value TV Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Collections.IKeyer-1.html": {
    "href": "api/RelogicLabs.JsonSchema.Collections.IKeyer-1.html",
    "title": "Interface IKeyer<TK> | Json Schema",
    "keywords": "Interface IKeyer<TK> Namespace RelogicLabs.JsonSchema.Collections Assembly RelogicLabs.JsonSchema.dll public interface IKeyer<out TK> Type Parameters TK Methods GetKey() TK GetKey() Returns TK"
  },
  "api/RelogicLabs.JsonSchema.Collections.IndexHashMap-2.html": {
    "href": "api/RelogicLabs.JsonSchema.Collections.IndexHashMap-2.html",
    "title": "Class IndexHashMap<TK, TV> | Json Schema",
    "keywords": "Class IndexHashMap<TK, TV> Namespace RelogicLabs.JsonSchema.Collections Assembly RelogicLabs.JsonSchema.dll public sealed class IndexHashMap<TK, TV> : IIndexMap<TK, TV>, IList<TV>, ICollection<TV>, IEnumerable<TV>, IEnumerable where TK : notnull where TV : IKeyer<TK> Type Parameters TK TV Inheritance object IndexHashMap<TK, TV> Implements IIndexMap<TK, TV> IList<TV> ICollection<TV> IEnumerable<TV> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors IndexHashMap(IEnumerable<TV>) public IndexHashMap(IEnumerable<TV> source) Parameters source IEnumerable<TV> Properties Count Gets the number of elements contained in the ICollection<T>. public int Count { get; } Property Value int The number of elements contained in the ICollection<T>. IsReadOnly Gets a value indicating whether the ICollection<T> is read-only. public bool IsReadOnly { get; } Property Value bool true if the ICollection<T> is read-only; otherwise, false. this[int] Gets or sets the element at the specified index. public TV this[int index] { get; set; } Parameters index int The zero-based index of the element to get or set. Property Value TV The element at the specified index. Exceptions ArgumentOutOfRangeException index is not a valid index in the IList<T>. NotSupportedException The property is set and the IList<T> is read-only. this[TK] public TV this[TK key] { get; } Parameters key TK Property Value TV Keys public IEnumerable<TK> Keys { get; } Property Value IEnumerable<TK> Values public IEnumerable<TV> Values { get; } Property Value IEnumerable<TV> Methods Add(TV) Adds an item to the ICollection<T>. public void Add(TV item) Parameters item TV The object to add to the ICollection<T>. Exceptions NotSupportedException The ICollection<T> is read-only. AsReadOnly() public IIndexMap<TK, TV> AsReadOnly() Returns IIndexMap<TK, TV> Clear() Removes all items from the ICollection<T>. public void Clear() Exceptions NotSupportedException The ICollection<T> is read-only. Contains(TV) Determines whether the ICollection<T> contains a specific value. public bool Contains(TV item) Parameters item TV The object to locate in the ICollection<T>. Returns bool true if item is found in the ICollection<T>; otherwise, false. CopyTo(TV[], int) Copies the elements of the ICollection<T> to an Array, starting at a particular Array index. public void CopyTo(TV[] array, int arrayIndex) Parameters array TV[] The one-dimensional Array that is the destination of the elements copied from ICollection<T>. The Array must have zero-based indexing. arrayIndex int The zero-based index in array at which copying begins. Exceptions ArgumentNullException array is null. ArgumentOutOfRangeException arrayIndex is less than 0. ArgumentException The number of elements in the source ICollection<T> is greater than the available space from arrayIndex to the end of the destination array. GetEnumerator() Returns an enumerator that iterates through the collection. public IEnumerator<TV> GetEnumerator() Returns IEnumerator<TV> An enumerator that can be used to iterate through the collection. IndexOf(TV) Determines the index of a specific item in the IList<T>. public int IndexOf(TV item) Parameters item TV The object to locate in the IList<T>. Returns int The index of item if found in the list; otherwise, -1. Insert(int, TV) Inserts an item to the IList<T> at the specified index. public void Insert(int index, TV item) Parameters index int The zero-based index at which item should be inserted. item TV The object to insert into the IList<T>. Exceptions ArgumentOutOfRangeException index is not a valid index in the IList<T>. NotSupportedException The IList<T> is read-only. Remove(TV) Removes the first occurrence of a specific object from the ICollection<T>. public bool Remove(TV item) Parameters item TV The object to remove from the ICollection<T>. Returns bool true if item was successfully removed from the ICollection<T>; otherwise, false. This method also returns false if item is not found in the original ICollection<T>. Exceptions NotSupportedException The ICollection<T> is read-only. RemoveAt(int) Removes the IList<T> item at the specified index. public void RemoveAt(int index) Parameters index int The zero-based index of the item to remove. Exceptions ArgumentOutOfRangeException index is not a valid index in the IList<T>. NotSupportedException The IList<T> is read-only. TryGetValue(TK, out TV?) public bool TryGetValue(TK key, out TV? value) Parameters key TK value TV Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.ClassInstantiationException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.ClassInstantiationException.html",
    "title": "Class ClassInstantiationException | Json Schema",
    "keywords": "Class ClassInstantiationException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class ClassInstantiationException : CommonException, ISerializable Inheritance object Exception CommonException ClassInstantiationException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ClassInstantiationException(ErrorDetail) public ClassInstantiationException(ErrorDetail detail) Parameters detail ErrorDetail ClassInstantiationException(ErrorDetail, Exception?) public ClassInstantiationException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception ClassInstantiationException(string, string) public ClassInstantiationException(string code, string message) Parameters code string message string ClassInstantiationException(string, string, Exception?) public ClassInstantiationException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.ClassNotFoundException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.ClassNotFoundException.html",
    "title": "Class ClassNotFoundException | Json Schema",
    "keywords": "Class ClassNotFoundException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class ClassNotFoundException : CommonException, ISerializable Inheritance object Exception CommonException ClassNotFoundException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ClassNotFoundException(ErrorDetail) public ClassNotFoundException(ErrorDetail detail) Parameters detail ErrorDetail ClassNotFoundException(string, string) public ClassNotFoundException(string code, string message) Parameters code string message string ClassNotFoundException(string, string, Exception?) public ClassNotFoundException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.CommonException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.CommonException.html",
    "title": "Class CommonException | Json Schema",
    "keywords": "Class CommonException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class CommonException : Exception, ISerializable Inheritance object Exception CommonException Implements ISerializable Derived ClassInstantiationException ClassNotFoundException DateTimeLexerException DefinitionNotFoundException DuplicateDefinitionException DuplicateIncludeException DuplicatePragmaException DuplicatePropertyKeyException FunctionNotFoundException InvalidDataTypeException InvalidDateTimeException InvalidFunctionException InvalidIncludeException InvalidPragmaValueException JsonLexerException JsonParserException JsonSchemaException PragmaNotFoundException SchemaLexerException SchemaParserException Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors CommonException(ErrorDetail) protected CommonException(ErrorDetail detail) Parameters detail ErrorDetail CommonException(ErrorDetail, Exception?) protected CommonException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception CommonException(string, string) protected CommonException(string code, string message) Parameters code string message string CommonException(string, string, Exception?) protected CommonException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception Properties Code public string Code { get; } Property Value string"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DateTimeLexerException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DateTimeLexerException.html",
    "title": "Class DateTimeLexerException | Json Schema",
    "keywords": "Class DateTimeLexerException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DateTimeLexerException : CommonException, ISerializable Inheritance object Exception CommonException DateTimeLexerException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DateTimeLexerException(string, string) public DateTimeLexerException(string code, string message) Parameters code string message string DateTimeLexerException(string, string, Exception?) public DateTimeLexerException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DefinitionNotFoundException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DefinitionNotFoundException.html",
    "title": "Class DefinitionNotFoundException | Json Schema",
    "keywords": "Class DefinitionNotFoundException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DefinitionNotFoundException : CommonException, ISerializable Inheritance object Exception CommonException DefinitionNotFoundException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DefinitionNotFoundException(ErrorDetail) public DefinitionNotFoundException(ErrorDetail detail) Parameters detail ErrorDetail DefinitionNotFoundException(string, string) public DefinitionNotFoundException(string code, string message) Parameters code string message string DefinitionNotFoundException(string, string, Exception?) public DefinitionNotFoundException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DuplicateDefinitionException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DuplicateDefinitionException.html",
    "title": "Class DuplicateDefinitionException | Json Schema",
    "keywords": "Class DuplicateDefinitionException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DuplicateDefinitionException : CommonException, ISerializable Inheritance object Exception CommonException DuplicateDefinitionException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DuplicateDefinitionException(ErrorDetail) public DuplicateDefinitionException(ErrorDetail detail) Parameters detail ErrorDetail DuplicateDefinitionException(string, string) public DuplicateDefinitionException(string code, string message) Parameters code string message string DuplicateDefinitionException(string, string, Exception?) public DuplicateDefinitionException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DuplicateIncludeException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DuplicateIncludeException.html",
    "title": "Class DuplicateIncludeException | Json Schema",
    "keywords": "Class DuplicateIncludeException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DuplicateIncludeException : CommonException, ISerializable Inheritance object Exception CommonException DuplicateIncludeException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DuplicateIncludeException(ErrorDetail) public DuplicateIncludeException(ErrorDetail detail) Parameters detail ErrorDetail DuplicateIncludeException(string, string, Exception?) public DuplicateIncludeException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DuplicatePragmaException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DuplicatePragmaException.html",
    "title": "Class DuplicatePragmaException | Json Schema",
    "keywords": "Class DuplicatePragmaException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DuplicatePragmaException : CommonException, ISerializable Inheritance object Exception CommonException DuplicatePragmaException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DuplicatePragmaException(ErrorDetail) public DuplicatePragmaException(ErrorDetail detail) Parameters detail ErrorDetail DuplicatePragmaException(string, string) public DuplicatePragmaException(string code, string message) Parameters code string message string DuplicatePragmaException(string, string, Exception?) public DuplicatePragmaException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DuplicatePropertyKeyException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DuplicatePropertyKeyException.html",
    "title": "Class DuplicatePropertyKeyException | Json Schema",
    "keywords": "Class DuplicatePropertyKeyException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DuplicatePropertyKeyException : CommonException, ISerializable Inheritance object Exception CommonException DuplicatePropertyKeyException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DuplicatePropertyKeyException(ErrorDetail) public DuplicatePropertyKeyException(ErrorDetail detail) Parameters detail ErrorDetail DuplicatePropertyKeyException(string, string) public DuplicatePropertyKeyException(string code, string message) Parameters code string message string DuplicatePropertyKeyException(string, string, Exception?) public DuplicatePropertyKeyException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.FunctionNotFoundException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.FunctionNotFoundException.html",
    "title": "Class FunctionNotFoundException | Json Schema",
    "keywords": "Class FunctionNotFoundException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class FunctionNotFoundException : CommonException, ISerializable Inheritance object Exception CommonException FunctionNotFoundException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors FunctionNotFoundException(ErrorDetail) public FunctionNotFoundException(ErrorDetail detail) Parameters detail ErrorDetail FunctionNotFoundException(string, string) public FunctionNotFoundException(string code, string message) Parameters code string message string FunctionNotFoundException(string, string, Exception?) public FunctionNotFoundException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.html",
    "title": "Namespace RelogicLabs.JsonSchema.Exceptions | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Exceptions Classes ClassInstantiationException ClassNotFoundException CommonException DateTimeLexerException DefinitionNotFoundException DuplicateDefinitionException DuplicateIncludeException DuplicatePragmaException DuplicatePropertyKeyException FunctionNotFoundException InvalidDataTypeException InvalidDateTimeException InvalidFunctionException InvalidIncludeException InvalidPragmaValueException JsonLexerException JsonParserException JsonSchemaException PragmaNotFoundException SchemaLexerException SchemaParserException"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidDataTypeException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidDataTypeException.html",
    "title": "Class InvalidDataTypeException | Json Schema",
    "keywords": "Class InvalidDataTypeException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidDataTypeException : CommonException, ISerializable Inheritance object Exception CommonException InvalidDataTypeException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidDataTypeException(ErrorDetail) public InvalidDataTypeException(ErrorDetail detail) Parameters detail ErrorDetail InvalidDataTypeException(ErrorDetail, Exception?) public InvalidDataTypeException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception InvalidDataTypeException(string, string) public InvalidDataTypeException(string code, string message) Parameters code string message string InvalidDataTypeException(string, string, Exception?) public InvalidDataTypeException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidDateTimeException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidDateTimeException.html",
    "title": "Class InvalidDateTimeException | Json Schema",
    "keywords": "Class InvalidDateTimeException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidDateTimeException : CommonException, ISerializable Inheritance object Exception CommonException InvalidDateTimeException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidDateTimeException(ErrorDetail) public InvalidDateTimeException(ErrorDetail detail) Parameters detail ErrorDetail InvalidDateTimeException(ErrorDetail, Exception?) public InvalidDateTimeException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception InvalidDateTimeException(string, string) public InvalidDateTimeException(string code, string message) Parameters code string message string InvalidDateTimeException(string, string, Exception?) public InvalidDateTimeException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidFunctionException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidFunctionException.html",
    "title": "Class InvalidFunctionException | Json Schema",
    "keywords": "Class InvalidFunctionException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidFunctionException : CommonException, ISerializable Inheritance object Exception CommonException InvalidFunctionException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidFunctionException(ErrorDetail) public InvalidFunctionException(ErrorDetail detail) Parameters detail ErrorDetail InvalidFunctionException(string, string) public InvalidFunctionException(string code, string message) Parameters code string message string InvalidFunctionException(string, string, Exception?) public InvalidFunctionException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidIncludeException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidIncludeException.html",
    "title": "Class InvalidIncludeException | Json Schema",
    "keywords": "Class InvalidIncludeException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidIncludeException : CommonException, ISerializable Inheritance object Exception CommonException InvalidIncludeException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidIncludeException(ErrorDetail) public InvalidIncludeException(ErrorDetail detail) Parameters detail ErrorDetail InvalidIncludeException(string, string) public InvalidIncludeException(string code, string message) Parameters code string message string InvalidIncludeException(string, string, Exception?) public InvalidIncludeException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidPragmaValueException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidPragmaValueException.html",
    "title": "Class InvalidPragmaValueException | Json Schema",
    "keywords": "Class InvalidPragmaValueException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidPragmaValueException : CommonException, ISerializable Inheritance object Exception CommonException InvalidPragmaValueException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidPragmaValueException(ErrorDetail) public InvalidPragmaValueException(ErrorDetail detail) Parameters detail ErrorDetail InvalidPragmaValueException(string, string) public InvalidPragmaValueException(string code, string message) Parameters code string message string InvalidPragmaValueException(string, string, Exception?) public InvalidPragmaValueException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.JsonLexerException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.JsonLexerException.html",
    "title": "Class JsonLexerException | Json Schema",
    "keywords": "Class JsonLexerException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class JsonLexerException : CommonException, ISerializable Inheritance object Exception CommonException JsonLexerException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors JsonLexerException(string, string) public JsonLexerException(string code, string message) Parameters code string message string JsonLexerException(string, string, Exception?) public JsonLexerException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.JsonParserException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.JsonParserException.html",
    "title": "Class JsonParserException | Json Schema",
    "keywords": "Class JsonParserException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class JsonParserException : CommonException, ISerializable Inheritance object Exception CommonException JsonParserException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors JsonParserException(string, string) public JsonParserException(string code, string message) Parameters code string message string JsonParserException(string, string, Exception?) public JsonParserException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.JsonSchemaException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.JsonSchemaException.html",
    "title": "Class JsonSchemaException | Json Schema",
    "keywords": "Class JsonSchemaException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class JsonSchemaException : CommonException, ISerializable Inheritance object Exception CommonException JsonSchemaException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors JsonSchemaException(ErrorDetail, ExpectedDetail, ActualDetail) public JsonSchemaException(ErrorDetail error, ExpectedDetail expected, ActualDetail actual) Parameters error ErrorDetail expected ExpectedDetail actual ActualDetail JsonSchemaException(ErrorDetail, ExpectedDetail, ActualDetail, Exception) public JsonSchemaException(ErrorDetail error, ExpectedDetail expected, ActualDetail actual, Exception innerException) Parameters error ErrorDetail expected ExpectedDetail actual ActualDetail innerException Exception Properties Actual public ActualDetail Actual { get; } Property Value ActualDetail Expected public ExpectedDetail Expected { get; } Property Value ExpectedDetail"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.PragmaNotFoundException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.PragmaNotFoundException.html",
    "title": "Class PragmaNotFoundException | Json Schema",
    "keywords": "Class PragmaNotFoundException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class PragmaNotFoundException : CommonException, ISerializable Inheritance object Exception CommonException PragmaNotFoundException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors PragmaNotFoundException(ErrorDetail) public PragmaNotFoundException(ErrorDetail detail) Parameters detail ErrorDetail PragmaNotFoundException(string, string) public PragmaNotFoundException(string code, string message) Parameters code string message string PragmaNotFoundException(string, string, Exception?) public PragmaNotFoundException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.SchemaLexerException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.SchemaLexerException.html",
    "title": "Class SchemaLexerException | Json Schema",
    "keywords": "Class SchemaLexerException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class SchemaLexerException : CommonException, ISerializable Inheritance object Exception CommonException SchemaLexerException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors SchemaLexerException(string, string) public SchemaLexerException(string code, string message) Parameters code string message string SchemaLexerException(string, string, Exception?) public SchemaLexerException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.SchemaParserException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.SchemaParserException.html",
    "title": "Class SchemaParserException | Json Schema",
    "keywords": "Class SchemaParserException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class SchemaParserException : CommonException, ISerializable Inheritance object Exception CommonException SchemaParserException Implements ISerializable Inherited Members CommonException.Code Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors SchemaParserException(string, string) public SchemaParserException(string code, string message) Parameters code string message string SchemaParserException(string, string, Exception?) public SchemaParserException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Functions.CoreFunctions.html": {
    "href": "api/RelogicLabs.JsonSchema.Functions.CoreFunctions.html",
    "title": "Class CoreFunctions | Json Schema",
    "keywords": "Class CoreFunctions Namespace RelogicLabs.JsonSchema.Functions Assembly RelogicLabs.JsonSchema.dll public sealed class CoreFunctions : FunctionBase Inheritance object FunctionBase CoreFunctions Inherited Members FunctionBase.Runtime FunctionBase.Function FunctionBase.FailWith(JsonSchemaException) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors CoreFunctions(RuntimeContext) public CoreFunctions(RuntimeContext runtime) Parameters runtime RuntimeContext Methods After(JDateTime, JString) public bool After(JDateTime target, JString reference) Parameters target JDateTime reference JString Returns bool Before(JDateTime, JString) public bool Before(JDateTime target, JString reference) Parameters target JDateTime reference JString Returns bool Date(JString, JString) public bool Date(JString target, JString pattern) Parameters target JString pattern JString Returns bool Elements(JArray, params JNode[]) public bool Elements(JArray target, params JNode[] items) Parameters target JArray items JNode[] Returns bool Email(JString) public bool Email(JString target) Parameters target JString Returns bool End(JDateTime, JString) public bool End(JDateTime target, JString reference) Parameters target JDateTime reference JString Returns bool Enum(JNumber, params JNumber[]) public bool Enum(JNumber target, params JNumber[] items) Parameters target JNumber items JNumber[] Returns bool Enum(JString, params JString[]) public bool Enum(JString target, params JString[] items) Parameters target JString items JString[] Returns bool Keys(JObject, params JString[]) public bool Keys(JObject target, params JString[] items) Parameters target JObject items JString[] Returns bool Length(JArray, JInteger) public bool Length(JArray target, JInteger length) Parameters target JArray length JInteger Returns bool Length(JArray, JInteger, JInteger) public bool Length(JArray target, JInteger minimum, JInteger maximum) Parameters target JArray minimum JInteger maximum JInteger Returns bool Length(JArray, JInteger, JUndefined) public bool Length(JArray target, JInteger minimum, JUndefined undefined) Parameters target JArray minimum JInteger undefined JUndefined Returns bool Length(JArray, JUndefined, JInteger) public bool Length(JArray target, JUndefined undefined, JInteger maximum) Parameters target JArray undefined JUndefined maximum JInteger Returns bool Length(JObject, JInteger) public bool Length(JObject target, JInteger length) Parameters target JObject length JInteger Returns bool Length(JObject, JInteger, JInteger) public bool Length(JObject target, JInteger minimum, JInteger maximum) Parameters target JObject minimum JInteger maximum JInteger Returns bool Length(JObject, JInteger, JUndefined) public bool Length(JObject target, JInteger minimum, JUndefined undefined) Parameters target JObject minimum JInteger undefined JUndefined Returns bool Length(JObject, JUndefined, JInteger) public bool Length(JObject target, JUndefined undefined, JInteger maximum) Parameters target JObject undefined JUndefined maximum JInteger Returns bool Length(JString, JInteger) public bool Length(JString target, JInteger length) Parameters target JString length JInteger Returns bool Length(JString, JInteger, JInteger) public bool Length(JString target, JInteger minimum, JInteger maximum) Parameters target JString minimum JInteger maximum JInteger Returns bool Length(JString, JInteger, JUndefined) public bool Length(JString target, JInteger minimum, JUndefined undefined) Parameters target JString minimum JInteger undefined JUndefined Returns bool Length(JString, JUndefined, JInteger) public bool Length(JString target, JUndefined undefined, JInteger maximum) Parameters target JString undefined JUndefined maximum JInteger Returns bool Maximum(JNumber, JNumber) public bool Maximum(JNumber target, JNumber maximum) Parameters target JNumber maximum JNumber Returns bool Maximum(JNumber, JNumber, JBoolean) public bool Maximum(JNumber target, JNumber maximum, JBoolean exclusive) Parameters target JNumber maximum JNumber exclusive JBoolean Returns bool Minimum(JNumber, JNumber) public bool Minimum(JNumber target, JNumber minimum) Parameters target JNumber minimum JNumber Returns bool Minimum(JNumber, JNumber, JBoolean) public bool Minimum(JNumber target, JNumber minimum, JBoolean exclusive) Parameters target JNumber minimum JNumber exclusive JBoolean Returns bool Negative(JNumber) public bool Negative(JNumber target) Parameters target JNumber Returns bool Nonempty(JArray) public bool Nonempty(JArray target) Parameters target JArray Returns bool Nonempty(JObject) public bool Nonempty(JObject target) Parameters target JObject Returns bool Nonempty(JString) public bool Nonempty(JString target) Parameters target JString Returns bool Phone(JString) public bool Phone(JString target) Parameters target JString Returns bool Positive(JNumber) public bool Positive(JNumber target) Parameters target JNumber Returns bool Range(JDateTime, JString, JString) public bool Range(JDateTime target, JString start, JString end) Parameters target JDateTime start JString end JString Returns bool Range(JDateTime, JString, JUndefined) public bool Range(JDateTime target, JString start, JUndefined end) Parameters target JDateTime start JString end JUndefined Returns bool Range(JDateTime, JUndefined, JString) public bool Range(JDateTime target, JUndefined start, JString end) Parameters target JDateTime start JUndefined end JString Returns bool Range(JNumber, JNumber, JNumber) public bool Range(JNumber target, JNumber minimum, JNumber maximum) Parameters target JNumber minimum JNumber maximum JNumber Returns bool Range(JNumber, JNumber, JUndefined) public bool Range(JNumber target, JNumber minimum, JUndefined undefined) Parameters target JNumber minimum JNumber undefined JUndefined Returns bool Range(JNumber, JUndefined, JNumber) public bool Range(JNumber target, JUndefined undefined, JNumber maximum) Parameters target JNumber undefined JUndefined maximum JNumber Returns bool Regex(JString, JString) public bool Regex(JString target, JString pattern) Parameters target JString pattern JString Returns bool Start(JDateTime, JString) public bool Start(JDateTime target, JString reference) Parameters target JDateTime reference JString Returns bool Time(JString, JString) public bool Time(JString target, JString pattern) Parameters target JString pattern JString Returns bool Url(JString) public bool Url(JString target) Parameters target JString Returns bool Url(JString, JString) public bool Url(JString target, JString scheme) Parameters target JString scheme JString Returns bool Values(JObject, params JNode[]) public bool Values(JObject target, params JNode[] items) Parameters target JObject items JNode[] Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Functions.FunctionBase.html": {
    "href": "api/RelogicLabs.JsonSchema.Functions.FunctionBase.html",
    "title": "Class FunctionBase | Json Schema",
    "keywords": "Class FunctionBase Namespace RelogicLabs.JsonSchema.Functions Assembly RelogicLabs.JsonSchema.dll public abstract class FunctionBase Inheritance object FunctionBase Derived CoreFunctions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FunctionBase(RuntimeContext) protected FunctionBase(RuntimeContext runtime) Parameters runtime RuntimeContext Properties Function public JFunction Function { get; set; } Property Value JFunction Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext Methods FailWith(JsonSchemaException) public bool FailWith(JsonSchemaException exception) Parameters exception JsonSchemaException Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Functions.html": {
    "href": "api/RelogicLabs.JsonSchema.Functions.html",
    "title": "Namespace RelogicLabs.JsonSchema.Functions | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Functions Classes CoreFunctions FunctionBase"
  },
  "api/RelogicLabs.JsonSchema.html": {
    "href": "api/RelogicLabs.JsonSchema.html",
    "title": "Namespace RelogicLabs.JsonSchema | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema Classes JsonAssert Provides assertion functionalities to validate JSON document against JSON Schema. JsonSchema Provides Schema validation functionalities for JSON document."
  },
  "api/RelogicLabs.JsonSchema.JsonAssert.html": {
    "href": "api/RelogicLabs.JsonSchema.JsonAssert.html",
    "title": "Class JsonAssert | Json Schema",
    "keywords": "Class JsonAssert Namespace RelogicLabs.JsonSchema Assembly RelogicLabs.JsonSchema.dll Provides assertion functionalities to validate JSON document against JSON Schema. public class JsonAssert Inheritance object JsonAssert Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors JsonAssert(string) Initializes a new instance of the JsonAssert class for the specified Schema string. public JsonAssert(string schema) Parameters schema string A Schema string for validation or conformation. Properties Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext SchemaTree public SchemaTree SchemaTree { get; } Property Value SchemaTree Methods AreEqual(string, string) Tests if the provided JSON strings are logically equivalent, meaning their structural composition and internal data are identical. If the JSON strings are not equivalent, an exception is thrown. public static void AreEqual(string jsonExpected, string jsonActual) Parameters jsonExpected string The expected JSON to compare. jsonActual string The actual JSON to compare. IsValid(string) Tests whether the input JSON string conforms to the Schema specified in the JsonAssert constructor. public void IsValid(string json) Parameters json string The actual JSON to conform or validate. IsValid(string, string) Tests whether the specified JSON string conforms to the given Schema string and throws an exception if the JSON string does not conform to the Schema. public static void IsValid(string schemaExpected, string jsonActual) Parameters schemaExpected string The expected Schema to conform or validate. jsonActual string The actual JSON to conform or validate."
  },
  "api/RelogicLabs.JsonSchema.JsonSchema.html": {
    "href": "api/RelogicLabs.JsonSchema.JsonSchema.html",
    "title": "Class JsonSchema | Json Schema",
    "keywords": "Class JsonSchema Namespace RelogicLabs.JsonSchema Assembly RelogicLabs.JsonSchema.dll Provides Schema validation functionalities for JSON document. public class JsonSchema Inheritance object JsonSchema Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors JsonSchema(string) Initializes a new instance of the JsonSchema class for the specified Schema string. public JsonSchema(string schema) Parameters schema string A Schema string for validation or conformation. Properties Exceptions public Queue<Exception> Exceptions { get; } Property Value Queue<Exception> Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext SchemaTree public SchemaTree SchemaTree { get; } Property Value SchemaTree Methods IsValid(string) Indicates whether the input JSON string conforms to the Schema specified in the JsonSchema constructor. public bool IsValid(string json) Parameters json string The JSON string to conform or validate with Schema. Returns bool true if the JSON string conforms to the Schema; otherwise, false. IsValid(string, string) Indicates whether the input JSON string conforms to the given Schema string. public static bool IsValid(string schema, string json) Parameters schema string The Schema string to conform or validate. json string The JSON string to conform or validate. Returns bool true if the JSON string conforms to the Schema; otherwise, false. WriteError() Writes error messages that occur during Schema validation process, to the standard error stream. public void WriteError()"
  },
  "api/RelogicLabs.JsonSchema.Message.ActualDetail.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.ActualDetail.html",
    "title": "Class ActualDetail | Json Schema",
    "keywords": "Class ActualDetail Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public sealed class ActualDetail : ContextDetail Inheritance object ContextDetail ActualDetail Inherited Members ContextDetail.Context ContextDetail.Message ContextDetail.Location object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ActualDetail(Context, string) public ActualDetail(Context context, string message) Parameters context Context message string ActualDetail(JNode, string) public ActualDetail(JNode node, string message) Parameters node JNode message string"
  },
  "api/RelogicLabs.JsonSchema.Message.ContextDetail.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.ContextDetail.html",
    "title": "Class ContextDetail | Json Schema",
    "keywords": "Class ContextDetail Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public abstract class ContextDetail Inheritance object ContextDetail Derived ActualDetail ExpectedDetail Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ContextDetail(Context, string) protected ContextDetail(Context context, string message) Parameters context Context message string ContextDetail(JNode, string) protected ContextDetail(JNode node, string message) Parameters node JNode message string Properties Context public Context Context { get; } Property Value Context Location public Location Location { get; } Property Value Location Message public string Message { get; } Property Value string"
  },
  "api/RelogicLabs.JsonSchema.Message.ErrorDetail.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.ErrorDetail.html",
    "title": "Class ErrorDetail | Json Schema",
    "keywords": "Class ErrorDetail Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public sealed class ErrorDetail Inheritance object ErrorDetail Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ErrorDetail(string, string) public ErrorDetail(string code, string message) Parameters code string message string Properties Code public string Code { get; } Property Value string Message public string Message { get; } Property Value string"
  },
  "api/RelogicLabs.JsonSchema.Message.ExpectedDetail.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.ExpectedDetail.html",
    "title": "Class ExpectedDetail | Json Schema",
    "keywords": "Class ExpectedDetail Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public sealed class ExpectedDetail : ContextDetail Inheritance object ContextDetail ExpectedDetail Inherited Members ContextDetail.Context ContextDetail.Message ContextDetail.Location object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ExpectedDetail(Context, string) public ExpectedDetail(Context context, string message) Parameters context Context message string ExpectedDetail(JNode, string) public ExpectedDetail(JNode node, string message) Parameters node JNode message string"
  },
  "api/RelogicLabs.JsonSchema.Message.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.html",
    "title": "Namespace RelogicLabs.JsonSchema.Message | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Message Classes ActualDetail ContextDetail ErrorDetail ExpectedDetail MessageFormatter"
  },
  "api/RelogicLabs.JsonSchema.Message.MessageFormatter.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.MessageFormatter.html",
    "title": "Class MessageFormatter | Json Schema",
    "keywords": "Class MessageFormatter Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public abstract class MessageFormatter Inheritance object MessageFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields JsonAssertion public static readonly MessageFormatter JsonAssertion Field Value MessageFormatter SchemaAssertion public static readonly MessageFormatter SchemaAssertion Field Value MessageFormatter SchemaValidation public static readonly MessageFormatter SchemaValidation Field Value MessageFormatter Properties Actual public string Actual { get; } Property Value string Expected public string Expected { get; } Property Value string OutlineLength public int OutlineLength { get; set; } Property Value int Summary public string Summary { get; } Property Value string Methods CreateOutline(string) public string CreateOutline(string target) Parameters target string Returns string"
  },
  "api/RelogicLabs.JsonSchema.Time.DateTimeType.html": {
    "href": "api/RelogicLabs.JsonSchema.Time.DateTimeType.html",
    "title": "Class DateTimeType | Json Schema",
    "keywords": "Class DateTimeType Namespace RelogicLabs.JsonSchema.Time Assembly RelogicLabs.JsonSchema.dll public sealed class DateTimeType Inheritance object DateTimeType Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Fields DATE_TYPE public static readonly DateTimeType DATE_TYPE Field Value DateTimeType TIME_TYPE public static readonly DateTimeType TIME_TYPE Field Value DateTimeType Properties Name public string Name { get; } Property Value string Type public JsonType Type { get; } Property Value JsonType Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Time.html": {
    "href": "api/RelogicLabs.JsonSchema.Time.html",
    "title": "Namespace RelogicLabs.JsonSchema.Time | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Time Classes DateTimeType JsonDateTime"
  },
  "api/RelogicLabs.JsonSchema.Time.JsonDateTime.html": {
    "href": "api/RelogicLabs.JsonSchema.Time.JsonDateTime.html",
    "title": "Class JsonDateTime | Json Schema",
    "keywords": "Class JsonDateTime Namespace RelogicLabs.JsonSchema.Time Assembly RelogicLabs.JsonSchema.dll public class JsonDateTime Inheritance object JsonDateTime Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Fields UNSET public const int UNSET = -1000 Field Value int Properties Day public int Day { get; } Property Value int Fraction public int Fraction { get; } Property Value int Hour public int Hour { get; } Property Value int Minute public int Minute { get; } Property Value int Month public int Month { get; } Property Value int Second public int Second { get; } Property Value int Type public DateTimeType Type { get; } Property Value DateTimeType UtcHour public int UtcHour { get; } Property Value int UtcMinute public int UtcMinute { get; } Property Value int Year public int Year { get; } Property Value int Methods Compare(JsonDateTime) public int Compare(JsonDateTime other) Parameters other JsonDateTime Returns int GetDayOfWeek() public DayOfWeek? GetDayOfWeek() Returns DayOfWeek? ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Tree.Context.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.Context.html",
    "title": "Class Context | Json Schema",
    "keywords": "Class Context Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class Context Inheritance object Context Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Context(ParserRuleContext, RuntimeContext) public Context(ParserRuleContext parser, RuntimeContext runtime) Parameters parser ParserRuleContext runtime RuntimeContext Properties Parser public ParserRuleContext Parser { get; } Property Value ParserRuleContext Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext Methods GetLocation() public Location GetLocation() Returns Location GetText() public string GetText() Returns string"
  },
  "api/RelogicLabs.JsonSchema.Tree.FunctionRegistry.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.FunctionRegistry.html",
    "title": "Class FunctionRegistry | Json Schema",
    "keywords": "Class FunctionRegistry Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class FunctionRegistry Inheritance object FunctionRegistry Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors FunctionRegistry(RuntimeContext) public FunctionRegistry(RuntimeContext runtime) Parameters runtime RuntimeContext Methods AddClass(JInclude) public JInclude AddClass(JInclude include) Parameters include JInclude Returns JInclude AddClass(string, Context?) public void AddClass(string className, Context? context = null) Parameters className string context Context InvokeFunction(JFunction, JNode) public bool InvokeFunction(JFunction function, JNode target) Parameters function JFunction target JNode Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Tree.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.html",
    "title": "Namespace RelogicLabs.JsonSchema.Tree | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Tree Classes Context FunctionRegistry JsonTree PragmaRegistry RuntimeContext SchemaTree Structs Location"
  },
  "api/RelogicLabs.JsonSchema.Tree.JsonTree.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.JsonTree.html",
    "title": "Class JsonTree | Json Schema",
    "keywords": "Class JsonTree Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class JsonTree Inheritance object JsonTree Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors JsonTree(RuntimeContext, string) public JsonTree(RuntimeContext context, string input) Parameters context RuntimeContext input string Properties Root public JRoot Root { get; } Property Value JRoot"
  },
  "api/RelogicLabs.JsonSchema.Tree.Location.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.Location.html",
    "title": "Struct Location | Json Schema",
    "keywords": "Struct Location Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public readonly record struct Location : IEquatable<Location> Implements IEquatable<Location> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Location(int, int) public Location(int Line, int Column) Parameters Line int Column int Properties Column public int Column { get; init; } Property Value int Line public int Line { get; init; } Property Value int Methods From(IToken) public static Location From(IToken token) Parameters token IToken Returns Location ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/RelogicLabs.JsonSchema.Tree.PragmaRegistry.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.PragmaRegistry.html",
    "title": "Class PragmaRegistry | Json Schema",
    "keywords": "Class PragmaRegistry Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class PragmaRegistry Inheritance object PragmaRegistry Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors PragmaRegistry() public PragmaRegistry() Properties DateDataTypeFormat public string DateDataTypeFormat { get; } Property Value string FloatingPointTolerance public double FloatingPointTolerance { get; } Property Value double IgnoreObjectPropertyOrder public bool IgnoreObjectPropertyOrder { get; } Property Value bool IgnoreUndefinedProperties public bool IgnoreUndefinedProperties { get; } Property Value bool TimeDataTypeFormat public string TimeDataTypeFormat { get; } Property Value string Methods AddPragma(JPragma) public JPragma AddPragma(JPragma pragma) Parameters pragma JPragma Returns JPragma GetPragma(string) public JPragma? GetPragma(string name) Parameters name string Returns JPragma GetPragmaValue<T>(string) public T GetPragmaValue<T>(string name) Parameters name string Returns T Type Parameters T"
  },
  "api/RelogicLabs.JsonSchema.Tree.RuntimeContext.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.RuntimeContext.html",
    "title": "Class RuntimeContext | Json Schema",
    "keywords": "Class RuntimeContext Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class RuntimeContext Inheritance object RuntimeContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Definitions public Dictionary<JAlias, JValidator> Definitions { get; } Property Value Dictionary<JAlias, JValidator> Exceptions public Queue<Exception> Exceptions { get; } Property Value Queue<Exception> Functions public FunctionRegistry Functions { get; } Property Value FunctionRegistry Pragmas public PragmaRegistry Pragmas { get; } Property Value PragmaRegistry ThrowException public bool ThrowException { get; set; } Property Value bool Methods AddDefinition(JDefinition) public JDefinition AddDefinition(JDefinition definition) Parameters definition JDefinition Returns JDefinition Retrieve(string) public object? Retrieve(string name) Parameters name string Returns object Store(string, object) public void Store(string name, object value) Parameters name string value object"
  },
  "api/RelogicLabs.JsonSchema.Tree.SchemaTree.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.SchemaTree.html",
    "title": "Class SchemaTree | Json Schema",
    "keywords": "Class SchemaTree Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class SchemaTree Inheritance object SchemaTree Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors SchemaTree(RuntimeContext, string) public SchemaTree(RuntimeContext context, string input) Parameters context RuntimeContext input string Properties Root public JRoot Root { get; } Property Value JRoot"
  },
  "api/RelogicLabs.JsonSchema.Types.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.html",
    "title": "Namespace RelogicLabs.JsonSchema.Types | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Types Classes JAlias JArray JBoolean JBranch JComposite JDataType JDate JDateTime JDefinition JDirective JDouble JFloat JFunction JInclude JInteger JLeaf JNode JNull JNumber JObject JPragma JPrimitive JProperty JRoot JString JTime JTitle JUndefined JValidator JVersion JsonType Interfaces IJsonType INestedMode IPragmaValue<T>"
  },
  "api/RelogicLabs.JsonSchema.Types.IJsonType.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.IJsonType.html",
    "title": "Interface IJsonType | Json Schema",
    "keywords": "Interface IJsonType Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public interface IJsonType Properties Node JNode Node { get; } Property Value JNode Type JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.INestedMode.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.INestedMode.html",
    "title": "Interface INestedMode | Json Schema",
    "keywords": "Interface INestedMode Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public interface INestedMode Fields NestedMarker public const string NestedMarker = \"*\" Field Value string Properties Nested bool Nested { get; } Property Value bool"
  },
  "api/RelogicLabs.JsonSchema.Types.IPragmaValue-1.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.IPragmaValue-1.html",
    "title": "Interface IPragmaValue<T> | Json Schema",
    "keywords": "Interface IPragmaValue<T> Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public interface IPragmaValue<out T> Type Parameters T Properties Value T Value { get; } Property Value T"
  },
  "api/RelogicLabs.JsonSchema.Types.JAlias.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JAlias.html",
    "title": "Class JAlias | Json Schema",
    "keywords": "Class JAlias Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JAlias : JLeaf Inheritance object JNode JLeaf JAlias Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Name public string Name { get; } Property Value string Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JArray.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JArray.html",
    "title": "Class JArray | Json Schema",
    "keywords": "Class JArray Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JArray : JComposite, IJsonType Inheritance object JNode JBranch JComposite JArray Implements IJsonType Inherited Members JComposite.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties Elements public IList<JNode> Elements { get; } Property Value IList<JNode> Type public override JsonType Type { get; } Property Value JsonType Methods GetComponents() public override IList<JNode> GetComponents() Returns IList<JNode> Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JBoolean.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JBoolean.html",
    "title": "Class JBoolean | Json Schema",
    "keywords": "Class JBoolean Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JBoolean : JPrimitive, IJsonType, IPragmaValue<bool> Inheritance object JNode JLeaf JPrimitive JBoolean Implements IJsonType IPragmaValue<bool> Inherited Members JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Value public bool Value { get; } Property Value bool Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator bool(JBoolean) public static implicit operator bool(JBoolean @bool) Parameters bool JBoolean Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Types.JBranch.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JBranch.html",
    "title": "Class JBranch | Json Schema",
    "keywords": "Class JBranch Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JBranch : JNode Inheritance object JNode JBranch Derived JComposite JDataType JFunction JProperty JValidator Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object)"
  },
  "api/RelogicLabs.JsonSchema.Types.JComposite.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JComposite.html",
    "title": "Class JComposite | Json Schema",
    "keywords": "Class JComposite Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JComposite : JBranch, IJsonType Inheritance object JNode JBranch JComposite Implements IJsonType Derived JArray JObject Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Node public JNode Node { get; } Property Value JNode Type public virtual JsonType Type { get; } Property Value JsonType Methods GetComponents() public abstract IList<JNode> GetComponents() Returns IList<JNode>"
  },
  "api/RelogicLabs.JsonSchema.Types.JDataType.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDataType.html",
    "title": "Class JDataType | Json Schema",
    "keywords": "Class JDataType Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JDataType : JBranch, INestedMode Inheritance object JNode JBranch JDataType Implements INestedMode Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Alias public JAlias? Alias { get; } Property Value JAlias JsonType public JsonType JsonType { get; } Property Value JsonType Nested public bool Nested { get; } Property Value bool Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. IsApplicable(JNode) public bool IsApplicable(JNode node) Parameters node JNode Returns bool Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. ToString(bool) public string ToString(bool baseForm) Parameters baseForm bool Returns string"
  },
  "api/RelogicLabs.JsonSchema.Types.JDate.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDate.html",
    "title": "Class JDate | Json Schema",
    "keywords": "Class JDate Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public class JDate : JDateTime, IJsonType, IPragmaValue<string> Inheritance object JNode JLeaf JPrimitive JString JDateTime JDate Implements IJsonType IPragmaValue<string> Inherited Members JDateTime.DateTime JString.Value JString.Match(JNode) JString.Equals(object) JString.GetHashCode() JString.ToString() JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.JDateTime.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDateTime.html",
    "title": "Class JDateTime | Json Schema",
    "keywords": "Class JDateTime Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public class JDateTime : JString, IJsonType, IPragmaValue<string> Inheritance object JNode JLeaf JPrimitive JString JDateTime Implements IJsonType IPragmaValue<string> Derived JDate JTime Inherited Members JString.Value JString.Match(JNode) JString.Equals(object) JString.GetHashCode() JString.ToString() JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties DateTime public JsonDateTime DateTime { get; } Property Value JsonDateTime Type public override JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.JDefinition.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDefinition.html",
    "title": "Class JDefinition | Json Schema",
    "keywords": "Class JDefinition Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JDefinition : JDirective Inheritance object JNode JDirective JDefinition Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Fields DefineMarker public const string DefineMarker = \"%define\" Field Value string Properties Alias public JAlias Alias { get; } Property Value JAlias Validator public JValidator Validator { get; } Property Value JValidator Methods ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JDirective.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDirective.html",
    "title": "Class JDirective | Json Schema",
    "keywords": "Class JDirective Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JDirective : JNode Inheritance object JNode JDirective Derived JDefinition JInclude JPragma JTitle JVersion Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Methods Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false."
  },
  "api/RelogicLabs.JsonSchema.Types.JDouble.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDouble.html",
    "title": "Class JDouble | Json Schema",
    "keywords": "Class JDouble Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JDouble : JNumber, IJsonType, IPragmaValue<double> Inheritance object JNode JLeaf JPrimitive JNumber JDouble Implements IJsonType IPragmaValue<double> Inherited Members JNumber.Compare(double) JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Value public double Value { get; } Property Value double Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToDouble() protected override double ToDouble() Returns double ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator double(JDouble) public static implicit operator double(JDouble @double) Parameters double JDouble Returns double"
  },
  "api/RelogicLabs.JsonSchema.Types.JFloat.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JFloat.html",
    "title": "Class JFloat | Json Schema",
    "keywords": "Class JFloat Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JFloat : JNumber, IJsonType, IPragmaValue<double> Inheritance object JNode JLeaf JPrimitive JNumber JFloat Implements IJsonType IPragmaValue<double> Inherited Members JNumber.Compare(double) JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Value public double Value { get; } Property Value double Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToDouble() protected override double ToDouble() Returns double ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator double(JFloat) public static implicit operator double(JFloat @float) Parameters float JFloat Returns double"
  },
  "api/RelogicLabs.JsonSchema.Types.JFunction.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JFunction.html",
    "title": "Class JFunction | Json Schema",
    "keywords": "Class JFunction Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JFunction : JBranch, INestedMode Inheritance object JNode JBranch JFunction Implements INestedMode Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties Arguments public IList<JNode> Arguments { get; } Property Value IList<JNode> Name public string Name { get; } Property Value string Nested public bool Nested { get; } Property Value bool Methods IsApplicable(JNode) public bool IsApplicable(JNode node) Parameters node JNode Returns bool Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. ToString(bool) public string ToString(bool baseForm) Parameters baseForm bool Returns string"
  },
  "api/RelogicLabs.JsonSchema.Types.JInclude.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JInclude.html",
    "title": "Class JInclude | Json Schema",
    "keywords": "Class JInclude Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JInclude : JDirective Inheritance object JNode JDirective JInclude Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields IncludeMarker public const string IncludeMarker = \"%include\" Field Value string Properties ClassName public string ClassName { get; } Property Value string Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JInteger.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JInteger.html",
    "title": "Class JInteger | Json Schema",
    "keywords": "Class JInteger Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JInteger : JNumber, IJsonType, IPragmaValue<long> Inheritance object JNode JLeaf JPrimitive JNumber JInteger Implements IJsonType IPragmaValue<long> Inherited Members JNumber.Compare(double) JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Value public long Value { get; } Property Value long Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToDouble() protected override double ToDouble() Returns double ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator double(JInteger) public static implicit operator double(JInteger integer) Parameters integer JInteger Returns double implicit operator long(JInteger) public static implicit operator long(JInteger integer) Parameters integer JInteger Returns long"
  },
  "api/RelogicLabs.JsonSchema.Types.JLeaf.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JLeaf.html",
    "title": "Class JLeaf | Json Schema",
    "keywords": "Class JLeaf Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JLeaf : JNode Inheritance object JNode JLeaf Derived JAlias JPrimitive JUndefined Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object)"
  },
  "api/RelogicLabs.JsonSchema.Types.JNode.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JNode.html",
    "title": "Class JNode | Json Schema",
    "keywords": "Class JNode Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JNode Inheritance object JNode Derived JBranch JDirective JLeaf JRoot Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Children public virtual IEnumerable<JNode> Children { get; } Property Value IEnumerable<JNode> Context public Context Context { get; } Property Value Context Parent public virtual JNode? Parent { get; } Property Value JNode Parser public ParserRuleContext Parser { get; } Property Value ParserRuleContext Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext Methods GetOutline() Returns an abbreviated outline version of the string obtained from the ToString() method of the specified length from OutlineLength and replaces a portion of the string with ellipses to match the specified length; otherwise, returns the string unmodified. public virtual string GetOutline() Returns string An abbreviated outline version of the ToString() string. Match(JNode) Determines whether the specified node matches with the current node. public abstract bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JNull.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JNull.html",
    "title": "Class JNull | Json Schema",
    "keywords": "Class JNull Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JNull : JPrimitive, IJsonType Inheritance object JNode JLeaf JPrimitive JNull Implements IJsonType Inherited Members JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields NullMarker public const string NullMarker = \"null\" Field Value string Properties Type public override JsonType Type { get; } Property Value JsonType Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JNumber.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JNumber.html",
    "title": "Class JNumber | Json Schema",
    "keywords": "Class JNumber Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JNumber : JPrimitive, IJsonType Inheritance object JNode JLeaf JPrimitive JNumber Implements IJsonType Derived JDouble JFloat JInteger Inherited Members JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Methods Compare(double) public int Compare(double other) Parameters other double Returns int Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. ToDouble() protected abstract double ToDouble() Returns double Operators implicit operator double(JNumber) public static implicit operator double(JNumber number) Parameters number JNumber Returns double"
  },
  "api/RelogicLabs.JsonSchema.Types.JObject.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JObject.html",
    "title": "Class JObject | Json Schema",
    "keywords": "Class JObject Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JObject : JComposite, IJsonType Inheritance object JNode JBranch JComposite JObject Implements IJsonType Inherited Members JComposite.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Properties public IIndexMap<string, JProperty> Properties { get; } Property Value IIndexMap<string, JProperty> Type public override JsonType Type { get; } Property Value JsonType Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetComponents() public override IList<JNode> GetComponents() Returns IList<JNode> GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JPragma.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JPragma.html",
    "title": "Class JPragma | Json Schema",
    "keywords": "Class JPragma Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JPragma : JDirective Inheritance object JNode JDirective JPragma Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields PragmaMarker public const string PragmaMarker = \"%pragma\" Field Value string Properties Name public string Name { get; } Property Value string Value public JPrimitive Value { get; } Property Value JPrimitive Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JPrimitive.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JPrimitive.html",
    "title": "Class JPrimitive | Json Schema",
    "keywords": "Class JPrimitive Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JPrimitive : JLeaf, IJsonType Inheritance object JNode JLeaf JPrimitive Implements IJsonType Derived JBoolean JNull JNumber JString Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Node public JNode Node { get; } Property Value JNode Type public virtual JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.JProperty.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JProperty.html",
    "title": "Class JProperty | Json Schema",
    "keywords": "Class JProperty Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JProperty : JBranch, IKeyer<string> Inheritance object JNode JBranch JProperty Implements IKeyer<string> Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Key public string Key { get; } Property Value string Value public JNode Value { get; } Property Value JNode Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. GetKey() public string GetKey() Returns string GetPropertyKey() public string GetPropertyKey() Returns string GetPropertyValue() public JNode GetPropertyValue() Returns JNode Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JRoot.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JRoot.html",
    "title": "Class JRoot | Json Schema",
    "keywords": "Class JRoot Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JRoot : JNode Inheritance object JNode JRoot Inherited Members JNode.Context JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties Definitions public IList<JDefinition>? Definitions { get; } Property Value IList<JDefinition> Includes public IList<JInclude>? Includes { get; } Property Value IList<JInclude> Parent public override JNode Parent { get; } Property Value JNode Pragmas public IList<JPragma>? Pragmas { get; } Property Value IList<JPragma> Title public JTitle? Title { get; } Property Value JTitle Value public JNode Value { get; } Property Value JNode Version public JVersion? Version { get; } Property Value JVersion Methods Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JsonType.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JsonType.html",
    "title": "Class JsonType | Json Schema",
    "keywords": "Class JsonType Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public class JsonType Inheritance object JsonType Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Fields ANY public static readonly JsonType ANY Field Value JsonType ARRAY public static readonly JsonType ARRAY Field Value JsonType BOOLEAN public static readonly JsonType BOOLEAN Field Value JsonType COMPOSITE public static readonly JsonType COMPOSITE Field Value JsonType DATE public static readonly JsonType DATE Field Value JsonType DATETIME public static readonly JsonType DATETIME Field Value JsonType DOUBLE public static readonly JsonType DOUBLE Field Value JsonType FLOAT public static readonly JsonType FLOAT Field Value JsonType INTEGER public static readonly JsonType INTEGER Field Value JsonType NULL public static readonly JsonType NULL Field Value JsonType NUMBER public static readonly JsonType NUMBER Field Value JsonType OBJECT public static readonly JsonType OBJECT Field Value JsonType PRIMITIVE public static readonly JsonType PRIMITIVE Field Value JsonType STRING public static readonly JsonType STRING Field Value JsonType TIME public static readonly JsonType TIME Field Value JsonType Properties Name public string Name { get; } Property Value string Type public Type Type { get; } Property Value Type Methods Match(JNode, out string) public bool Match(JNode node, out string error) Parameters node JNode error string Returns bool ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JString.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JString.html",
    "title": "Class JString | Json Schema",
    "keywords": "Class JString Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public class JString : JPrimitive, IJsonType, IPragmaValue<string> Inheritance object JNode JLeaf JPrimitive JString Implements IJsonType IPragmaValue<string> Derived JDateTime Inherited Members JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Value public string Value { get; } Property Value string Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator string(JString) public static implicit operator string(JString @string) Parameters string JString Returns string"
  },
  "api/RelogicLabs.JsonSchema.Types.JTime.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JTime.html",
    "title": "Class JTime | Json Schema",
    "keywords": "Class JTime Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public class JTime : JDateTime, IJsonType, IPragmaValue<string> Inheritance object JNode JLeaf JPrimitive JString JDateTime JTime Implements IJsonType IPragmaValue<string> Inherited Members JDateTime.DateTime JString.Value JString.Match(JNode) JString.Equals(object) JString.GetHashCode() JString.ToString() JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.JTitle.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JTitle.html",
    "title": "Class JTitle | Json Schema",
    "keywords": "Class JTitle Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JTitle : JDirective Inheritance object JNode JDirective JTitle Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Fields TitleMarker public const string TitleMarker = \"%title\" Field Value string Properties Title public string Title { get; } Property Value string Methods ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JUndefined.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JUndefined.html",
    "title": "Class JUndefined | Json Schema",
    "keywords": "Class JUndefined Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JUndefined : JLeaf Inheritance object JNode JLeaf JUndefined Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields UndefinedMarker public const string UndefinedMarker = \"!\" Field Value string Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JValidator.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JValidator.html",
    "title": "Class JValidator | Json Schema",
    "keywords": "Class JValidator Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JValidator : JBranch Inheritance object JNode JBranch JValidator Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Fields OptionalMarker public const string OptionalMarker = \"?\" Field Value string Properties DataTypes public IList<JDataType> DataTypes { get; } Property Value IList<JDataType> Functions public IList<JFunction> Functions { get; } Property Value IList<JFunction> Optional public bool Optional { get; } Property Value bool Value public JNode? Value { get; } Property Value JNode Methods Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JVersion.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JVersion.html",
    "title": "Class JVersion | Json Schema",
    "keywords": "Class JVersion Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JVersion : JDirective Inheritance object JNode JDirective JVersion Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Parser JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Fields VersionMarker public const string VersionMarker = \"%version\" Field Value string Properties Version public string Version { get; } Property Value string Methods ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "articles/datatypes.html": {
    "href": "articles/datatypes.html",
    "title": "Constraint Data Types | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } Constraint Data Types Data types play a pivotal role in validating JSON data for compliance with the schema. Essentially, data types determine the kind of data that a JSON element or value can contain. This mechanism serves as a fundamental process in maintaining the accuracy, consistency, and integrity of JSON document and its structure throughout the system, where data quality and reliability are vital. In the schema document, data types are denoted by the # prefix. Here is an outline of all data types, including their subtypes, used in the schema document to validate a JSON document. When using multiple data types for validation, it indicates that the JSON value is considered valid if it complies with any of the specified alternative data types. All of these data types and their subtypes offer the flexibility of selecting the most appropriate type based on requirements. #any   #primitive     #string       #datetime       #date    #time   #number       #integer    #float    #double   #boolean   #null  #composite   #array  #object The Any Data Type This data type accepts any valid JSON value that conforms to the JSON standard. It is the least restrictive data type and serves as the parent type for all other data types defined in this schema, each of which imposes more specific constraints. Here is the specification of JSON document containing rules of all valid JSON values. Following is the syntax for specifying this data type: #any The Object Data Type This data type represents the JSON object type and accepts any JSON object specified by the JSON standard. The specification document for JSON provides details about the different syntax and forms of JSON objects. Following is the syntax for specifying this data type: #object The Array Data Type This data type represents the JSON array type and accepts any JSON array specified by the JSON standard. The specification document for JSON provides details about the various syntax and forms of JSON arrays. Below is the syntax for specifying this data type: #array The String Data Type This is one of the most commonly used data types in a JSON document, designed to accept any JSON string as specified by the JSON standard. The syntax for specifying this data type is as follows: #string The Date Time Data Type The date-time data type serves as the parent data type for both date and time data types. It is a subtype of string data type and thus formatted as per the JSON string specification. #datetime The Date Data Type The date data type accepts a string representation of a date, conforming to the ISO 8601 standard (date part only). This behavior is based on the default configuration, which can be modified as needed. It is a subtype of date-time type and thus also formatted as per the JSON string specification. Detailed explanations of the ISO 8601 standard can be found in this document. Furthermore, you can refer to this document for a detailed description of the date pattern associated with this data type. To define this data type in schema, use the following syntax: #date The Time Data Type The time data type accepts a string representation of a time (including both date and time parts), in accordance with the ISO 8601 standard. This behavior is based on the default configuration, which can be modified as needed. Similar to the date data type, it is a subtype of date-time data type and thus also formatted as per the JSON string specification. Here is the ISO 8601 standard document, which contains detailed explanations. Furthermore, you can refer to this document for a detailed description of the date-time pattern associated with this data type. To define this data type in schema, use the following syntax: #time The Number Data Type The number data type serves as the parent data type for all numeric types accommodated by the schema, including integer, floating-point, and exponent-based numbers. It accepts any JSON numerical value in accordance with the JSON standard. The syntax for specifying the number type is as follows: #number The Integer Data Type The integer data type is a subtype of the number data type that only allows integral numbers or whole numbers without any fraction and exponent and thus provides constraints for a wide range of real-world scenarios where numbers cannot involve decimal points or exponents. To specify the integer type in schema, use the following syntax: #integer The Float Data Type The float data type is also a subtype of the number data type that only accepts floating point numbers and does not allow exponent in numbers or integral numbers. This constraint is useful for various real-world applications that require numbers to be exclusively in floating-point format. To specify the float type in schema, use the following syntax: #float The Double Data Type The double data type, as a subtype of the number data type, exclusively accepts numbers with exponents. It can either be an integral number with an exponent or a floating-point number with an exponent. This constraint distinguishes it from other number formats and makes it particularly useful for handling large numbers with exponents. To specify the double type in a schema, use the following syntax: #double The Boolean Data Type The boolean data type is a binary or switch-based data type that only accepts two values, namely true and false. It is particularly useful in situations where toggling and switching are necessary. To specify the boolean type in the schema, use the following syntax: #boolean The Null Data Type The null data type serves as a special constraint within JSON schemas, facilitating the controlled use of null in place of other JSON elements or values. Typically, it is combined with other data types to permit the use of null for specific JSON elements or values. This can set constraints for scenarios in which an array without any elements and an object without any properties can either have null or only be allowed to be empty. Additionally, the @nonempty constraint functions can be employed to further control the use of empty values within a JSON document. To specify the null type in the schema, use the following syntax: #null"
  },
  "articles/datetime.html": {
    "href": "articles/datetime.html",
    "title": "Date and Time Patterns | Json Schema",
    "keywords": "Date and Time Patterns Dates and times are fundamental data types used in a wide range of data exchange scenarios. This schema offers a comprehensive set of tools for managing dates and times, including pattern-based formatting to meet the unique requirements of various systems and applications. Simultaneously, it incorporates validation processes to ensure compliance with the schema. Date and time formats are defined using date and time pattern strings. Within these pattern strings, unquoted letters ranging from 'A' to 'Z' and 'a' to 'z' serve as placeholders representing various components of a date or time string. To prevent their interpretation as patterns, text can be enclosed in single quotes ('). Additionally, two consecutive single quotes ('') are used to represent a literal single quote within the string. Any characters outside of these uppercase and lowercase letters, as well as the text enclosed in single quotes, are not interpreted and are matched against the input string during validation. Below, you will find a list of pattern letters and strings that are defined for date and time patterns. Please note that any characters within the 'A' to 'Z' and 'a' to 'z' range are reserved and should not be directly included in the pattern string. SN Pattern Description Example 1 G Era period designator AD 2 YYYY Four digit year number 1970 3 YY Two digit year number 70 4 MM Month number in year (2 digit form) 01 5 MMMM Full name of month January 6 MMM Short name of month Jan 7 M Month number in year (1-2 digit form) 1; 01 8 DDDD Full name of day in week Monday 9 DDD Short name of day in week Mon 10 DD Day in month (2 digit form) 01 11 D Day in month (1-2 digit form) 1; 01 12 t AM/PM designator AM; PM 13 hh Hour in day (2 digit form) 01; 12 14 h Hour in day (1-2 digit form) 1; 01 15 mm Minute in hour (2 digit form) 01; 20 16 m Minute in hour (1-2 digit form) 1; 01 17 ss Second in minute (2 digit form) 01; 30 18 s Second in minute (1-2 digit form) 1; 01 19 f Tenths of a second 1 20 ff Hundredths of a second 11 21 fff Milliseconds of a second 111 22 ffff Ten thousandths of a second 1111 23 fffff Hundred thousandths of a second 11111 24 ffffff Millionths of a second 111111 25 F Fraction of a second upto 6 digits 1; 111; 111111 26 Z Time zone hours only offset +06; -05; Z 27 ZZ Time zone hours and minutes offset +09:30; 03:30; Z 28 ZZZ Time zone hours and minutes offset +0930; 0330; Z The pattern components listed above can be combined to create comprehensive and customized date and time patterns to accommodate all system and user requirements. The following table illustrates some examples of how different date-time pattern components can be combined. SN Usage Combined Pattern Example 1 #date YYYY-MM-DD 2023-09-01 2 #time YYYY-MM-DD'T'hh:mm:ss.FZZ 2023-09-01T14:35:10.111+06:00 3 @date MMMM DD, YYYY G January 01, 1980 AD 4 @date DDDD, D MMMM YYYY Tuesday, 11 July 2023 5 @time YYYY.MM.DD hh.mm.ss t 1980.11.21 10.30.50 pm 6 @time DDD, D MMM YY hh:mm:ss ZZ Sun, 4 Jul 99 12:08:56 -06:00 7 @time hh:mm:ss t ZZ 03:11:30 AM +06:00 The first pattern in the table above adheres to the ISO 8601 date format and is used to validate the #date data type within the schema. The second pattern in the table follows the ISO 8601 format for date and time, validating the #time data type in the schema. Instead of explicitly specifying these patterns in the @date or @time functions, a more concise approach is to directly utilize the #date or #time type within the schema. Detailed explanations regarding the date and time format of the ISO 8601 standard are available in this document. When the AM/PM designator is included in the date and time pattern, the presence of any hour format specifier indicates that the time is in the 12-hour clock format. Conversely, when the AM/PM designator is omitted, the presence of any hour format specifier indicates that the time is in the 24-hour clock format."
  },
  "articles/directives.html": {
    "href": "articles/directives.html",
    "title": "Validation Directives | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } Validation Directives Directives serve as special instructions or commands for the Schema and JSON parsers, interpreters, and validators. They are used to control various aspects of the validation process or to provide metadata for documentation. Additionally, they offer crucial information about Schema and JSON and provide custom validation functions to meet specific Schema validation requirements. Title Directive Within a schema, the title directive is used to provide a name, label, or a brief intent of the schema for which it is written. Besides, the title directive is optional and additional description can be supplied as multiple comments inside the schema document to provide more detail. However, this directive is only used for documentation purposes and does not have any impact in the validation process. To represent the title directive, the following example of notation can be used: %title: \"Example name or brief description\" Version Directive In a schema, the version directive is used to provide a version number of the schema which helps to keep track of updates. Although optional, the version directive is useful for documentation purposes and does not affect the validation process. The version directive can be represented using the following notation example: %version: 2023.09.11.01 Include Directive Include directive enables the addition or inclusion of a class, as defined by object-oriented programming, to a schema along with a set of methods that have specific signatures for performing custom validations. This feature extends the built-in validation capabilities of the schema. In the C# language, it is also necessary to specify the assembly name together with the class name. The example below illustrates how to utilize the include directive in C# language: %include: RelogicLabs.JsonSchema.Tests.Positive.ExternalFunctions, RelogicLabs.JsonSchema.Tests Pragma Directive Pragma directives provide a mechanism to modify the default settings for certain predefined parameters of the validation process. This allows you to adjust the behaviours of schema validation process as per your requirements. Ignore Undefined Properties The IgnoreUndefinedProperties pragma directive serves the purpose of instructing the validation process on how to handle JSON properties that are not explicitly defined in the schema, not even by the undefined marker or symbol. You can use this directive to specify whether such properties should be ignored during validation or if validation errors should be raised for any undefined properties in the JSON document. The default value of this directive is false, which means that by default, undefined properties in the JSON document are not ignored, and validation errors will be raised for them. For example, the following usage of this directive instructs the validation process to ignore any undefined properties in the JSON document: %pragma IgnoreUndefinedProperties: true Date Data Type Format The DateDataTypeFormat pragma directive enables you to customize the default format of the #date data type. By default, the #date data type follows the ISO 8601 standard, precisely using the format YYYY-MM-DD. Additional details on date-time patterns and formats are available here. The subsequent example illustrates the process of defining a customized date format for the #date data type: %pragma DateDataTypeFormat: \"DD-MM-YYYY\" Time Data Type Format To customize the default format of the #time data type, utilize the TimeDataTypeFormat pragma directive. By default, the #time data type follows the ISO 8601 standard, precisely in the format YYYY-MM-DD'T'hh:mm:ss.FZZ. Further information on date-time patterns and formats can be found here. The following example demonstrates how to specify a customized time format for the #time data type: %pragma TimeDataTypeFormat: \"DD-MM-YYYY hh:mm:ss\" Floating Point Tolerance The FloatingPointTolerance pragma directive allows you to define the tolerance level for relative errors in floating-point numbers during calculations and computations carried out by the validation process. By default, this directive is set to 1E-10, indicating a small tolerance. However, you have the flexibility to adjust this value to any desired number. To specify a custom tolerance value of 1E-07, you can use the following notation as an example: %pragma FloatingPointTolerance: 1E-07 Ignore Object Property Order The IgnoreObjectPropertyOrder pragma directive provides a means to enforce a specific order or sequence of JSON object properties, following the schema definition. This requirement for strict ordering is only needed in certain special cases. By default, this directive is set to true, meaning that the object property order outlined in the schema document is not mandatory. However, you can override this default by setting it to false, as shown in the following example below: %pragma IgnoreObjectPropertyOrder: false Definition / Define Directive This feature in JSON schemas allows you to define a name for a fragment of schema or validation rules, which can be referenced from various parts of your schema. This means that if you encounter similar validation requirements in different sections of your schema, you can conveniently refer to the named fragment instead of duplicating the same validation rules. By providing clear and descriptive names for these validation rules or sub-schemas, you enhance the overall clarity and context of your schema. This clarity not only makes it easier to understand the structure and intent of the schema but also contributes to keeping your complex schema well-organized, concise, and more manageable. The name or alias of the directive is always start with $ which also refers to that they are named fragment defined elsewhere in the schema. Here is a simple example of how to use this directive: %define $product: { \"id\": @length(2, 10) @regex(\"[a-z][a-z0-9]+\") #string, \"name\": @length(5, 100) #string, \"price\": @range(0.1, 1000000), \"inStock\": #boolean } Schema Directive The schema directive serves as the starting or entry point for both the schema document and the schema validation process. It becomes mandatory when other directives are present within the document. In such cases, the schema directive explicitly designates the beginning of the schema document and defines the entry point for validation process. However, if there are no other directives used in the document, the entire document itself is automatically considered as the schema document, with the document's beginning serving as its entry point. To illustrate, here is a simple example of a schema document with schema directive: %schema: { \"user\": { \"id\": @range(1, 10000) #integer, /*username does not allow special characters*/ \"username\": @regex(\"[a-z_]{3,30}\") #string, /*currently only one role is allowed by system*/ \"role\": \"user\" #string, \"isActive\": #boolean, //user account current status \"registeredAt\": #time } }"
  },
  "articles/functions.html": {
    "href": "articles/functions.html",
    "title": "Constraint Functions | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } table th:first-of-type { min-width: 140px; } Constraint Functions This document serves as a brief overview, providing key insights into the built-in constraint functions that are part of the core schema. These functions significantly extend the scope of data and structural validation, going beyond the limits of basic data type restrictions. These functions are designed to enhance the effectiveness of schema validation, ensuring the accuracy, consistency, integrity, and compliance of the JSON data to the schema. The notation below outlines the typical structure of constraint or validation functions applicable to JSON elements or values. In this notation, Target comprises two components: the target type, which specifies the JSON value type under consideration, and the target name, which identifies the specific JSON value to which the validation or constraint function applies. The Constraint-Function refers to the name of the function responsible for the validation. Target - Constraint-Function[(Parameter-Set)] The Parameter-Set contains the parameters that control the validation process provided by the constraint function on the target JSON value. Please note that the Parameter-Set including the opening and closing parentheses are optional. The ellipsis or three dots ... after a parameter type indicates it can accept any number of arguments of that type. When using multiple validation functions, each function validates the target JSON value, and the overall validation succeeds only when every function independently deems the target JSON value as valid. Function Details Below, you will find a detailed explanation of the syntax and useful applications of each function, allowing you to gain a clear understanding of their usage. String Length #string target - @length(#integer number) Validates that the target string has the length specified by the number. If the length of the target string does not match the value specified by number, a validation error will generate. #string target - @length(#integer minimum, #integer maximum) Validates that the length of the target string satisfies the range requirement specified by the parameters. It checks that the length of the target string is equal to or greater than the minimum length specified and simultaneously less than or equal to the maximum length specified. If not, a validation error will generate. If either the parameter values for minimum or maximum are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @length function of the two variations described above, for the target data type string: Ues Cases Valid Values Invalid Values @length(4) \"ABCD\" \"AB\"; \"ABCDE\" @length(2, 4) \"AB\"; \"ABC\"; \"ABCD\" \"\"; \"A\"; \"ABCDE\" @length(2, !) \"AB\"; \"ABCDEFGH\" \"\"; \"A\" @length(!, 4) \"\"; \"A\"; \"ABC\"; \"ABCD\" \"ABCDE\"; \"ABCDEFGHI\" Array Length #array target - @length(#integer number) Validates that the target array has the length specified by the number. If the length of the target array does not match the value specified by number, a validation error will generate. #array target - @length(#integer minimum, #integer maximum) Validates that the length of the target array satisfies the range requirement specified by the parameters. It checks that the length of the target array is equal to or greater than the minimum length specified and simultaneously less than or equal to the maximum length specified. If not, a validation error will generate. If either the parameter values for minimum or maximum are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @length function of the two variations described above, for the target data type array: Ues Cases Valid Values Invalid Values @length(4) [1, 2, 3, 4] [1, 2, 3]; [1, 2, 3, 4, 5] @length(2, 4) [1, 2]; [1, 2, 3]; [1, 2, 3, 4] []; [1]; [1, 2, 3, 4, 5] @length(2, !) [1, 2]; [1, 2, 3, 4, 5] []; [1] @length(!, 4) []; [1, 2]; [1, 2, 3, 4] [1, 2, 3, 4, 5]; [1, 2, 3, 4, 5, 6] Object Length / Size #object target - @length(#integer number) Validates that the target object has the length or size specified by the number. If the length of the target object does not match the value specified by number, a validation error will generate. #object target - @length(#integer minimum, #integer maximum) Validates that the length or size of the target object satisfies the range requirement specified by the parameters. It checks that the length of the target object is equal to or greater than the minimum length specified and simultaneously less than or equal to the maximum length specified. If not, a validation error will generate. If either the parameter values for minimum or maximum are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @length function of the two variations described above, for the target data type object: Ues Cases Valid Values Invalid Values @length(4) {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4} {\"k1\":1, \"k2\":2, \"k3\":3}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4, \"k5\":5} @length(2, 4) {\"k1\":1, \"k2\":2}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4} {}; {\"k1\":1}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4, \"k5\":5} @length(2, !) {\"k1\":1, \"k2\":2}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4, \"k5\":5} {}; {\"k1\":1} @length(!, 4) {}; {\"k1\":1, \"k2\":2}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4} {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4, \"k5\":5} Number Range #number target - @range(#number minimum, #number maximum) Validates that the target number satisfies the range requirement specified by the parameters. It checks that the target number is greater than or equal to the minimum number specified and simultaneously less than or equal to the maximum number specified. If not, a validation error will generate. If either the parameter values for minimum or maximum are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @range function of the two variations described above, for the target data type number: Ues Cases Valid Values Invalid Values @range(2, 4) 2; 3; 4 0; 1; -100; 100 @range(2, !) 2; 3; 4; 100 0; 1; -100 @range(!, 4) 0; 1; 4; -100 5; 10; 100 Number Minimum #number target - @minimum(#number minimum) #number target - @minimum(#number minimum, #boolean exclusive) Validates that the target number is greater than or equal to the minimum number specified as a parameter, unless the exclusive parameter flag is explicitly set to true, in which case the target number must be exclusively greater than the minimum number. Ues Cases Valid Values Invalid Values minimum(0) 0; 1; 1000 -1; -10; -10000 minimum(10.5) 10.5; 10.6; 1000.1 10.49; 1.0; -100.1 minimum(0, true) 0.001; 1.01; 100.1 0; -0.01; -100.1 Number Maximum #number target - @maximum(#number maximum) #number target - @maximum(#number maximum, #boolean exclusive) Validates that the target number is less than or equal to the maximum number specified as a parameter, unless the exclusive parameter flag is explicitly set to true, in which case the target number must be exclusively less than the maximum number. Ues Cases Valid Values Invalid Values maximum(100) 100; -100; 0 101; 1000; 10000 maximum(10.5) 10.50; 10.49; -1000.1 10.51; 11.0; 1000.1 maximum(0, true) -0.001; -1.01; -1000.1 0; 0.01; 100.1 String Enum #string target - @enum(#string... items) Validates that the target string is equal to one of the strings specified by the items parameter. If not, a validation error will generate. Number Enum #number target - @enum(#number... items) Validates that the target number is equal to one of the numbers specified by the items parameter. If not, a validation error will generate. Array Elements #array target - @elements(#any... items) Validates that the target array contains every JSON value specified by the items parameter. If not, it generates a validation error. Object Keys #object target - @keys(#string... items) Validates that all the strings specified in the items parameter are present as keys in the target object. If any of them is missing, a validation error is generated. Object Values #object target - @values(#any... items) Validates that all the JSON values specified in the items parameter are present as values in the target object. If any of them is missing, a validation error is generated. String Regular Expression (Regex) #string target - @regex(#string pattern) Validates that the target string matches the regular expression pattern specified by the pattern parameter. The regular expression engine used here supports standard syntax from both POSIX (IEEE Portable Operating System Interface) Extended Regular Expressions and Perl-Compatible Regular Expressions (PCRE). For more details, please refer to POSIX Regular Expressions. Email Address #string target - @email Validates whether the target string represents a valid email address. It follows the SMTP protocol RFC 5322 specification for mailbox address format to identify a valid email address. In addition to conforming to this standard, it recognizes all widely used email address formats to ensure compatibility with various systems and user requirements. URL & URI Address #string target - @url(#string scheme) Validates whether the target string is a valid URL (Uniform Resource Locator) or URI (Uniform Resource Identifier) with a specific scheme provided by the scheme parameter. It follows the RFC 3986 URI Generic Syntax to determine the validity of the URL or URI. In addition to conforming to this standard, it recognizes all widely used URL and URI address formats, ensuring compatibility with a wide range of systems and user requirements. #string target - @url Validates whether the target string is a valid URL or URI with HTTP and HTTPS scheme. For more information please check the function #string target - @url(#string scheme). Phone Number #string target - @phone Validates whether the target string is a valid phone number. It follows the ITU-T E.163 and E.164 telephone number notation to determine the validity of the phone number. In addition to conforming to this standard, it recognizes all widely used national and international phone number formats, ensuring compatibility with a wide range of systems and user requirements. Date and Time #string target - @date(pattern) Validates that the target string matches the date and time pattern specified by the pattern parameter. It fully supports the ISO 8601 date and time format. Beyond this standard, it also allows custom date and time formats, ensuring compatibility with various systems and meeting diverse users and businesses requirements. This document provides a comprehensive overview of the date-time custom patterns. #string target - @time(pattern) Both the @date and @time functions support a complete range of date-time patterns, enabling the precise definition of any date and time scenario. Therefore, these functions can be used interchangeably. When the sole consideration is the date or day of the month in a year, employing the @date function is the more convenient choice. In contrast, when it becomes necessary to specify a particular time on a date, the @time function is the more appropriate option. To learn more about date-time patterns, please refer to this page. Date and Time Range #datetime target - @range(#string start, #string end) Validates that the target date-time satisfies the range requirement specified by the parameters. It checks that the target date-time is from or after the start date-time specified and simultaneously until and before the end date-time specified. If not, a validation error will generate. The start and end parameters must be the string representation of the target data type, which can either be a #date or #time type. If either the parameter values for start or end are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @range function of the two variations described above, for the target type: Ues Cases Valid Values Invalid Values @range(\"2010-01-01\", \"2010-12-31\") 2010-01-01; 2010-06-30; 2010-12-31 2009-12-31; 2011-01-01; 2030-11-05 @range(\"2010-01-01T00:00:00.000Z\", \"2010-12-31T23:59:59.999Z\") 2010-01-01T00:00:00.000Z; 2010-12-31T23:59:59.999Z 2009-12-31T23:59:59.999Z @range(!, \"2010-12-31\") 1990-01-01; 2010-12-31 2011-01-01; 2030-11-05 @range(\"2010-01-01\", !) 2010-01-01; 2030-11-05 1990-01-01; 2009-12-31 Date and Time Start #datetime target - @start(#string reference) Validates that the target date-time starts from or finds after the specified reference date-time parameter. If the target date-time finds before the reference date-time, a validation error is triggered. The reference parameter must be the string representation of the target data type, which can either be a #date or #time type. Date and Time End #datetime target - @end(#string reference) Validates that the target date-time finds before or ends at the specified reference date-time parameter. If the target date-time finds after the reference date-time, a validation error is triggered. The reference parameter must be the string representation of the target data type, which can either be a #date or #time type. Date and Time Before #datetime target - @before(#string reference) Validates that the target date-time is exclusively before the reference date-time. If the target date-time finds on or after the reference date-time, a validation error is triggered. The reference parameter must be the string representation of the target data type, which can either be a #date or #time type. Date and Time After #datetime target - @after(#string reference) Validates that the target date-time is exclusively after the reference date-time. If the target date-time finds on or before the reference date-time, a validation error is triggered. The reference parameter must be the string representation of the target data type, which can either be a #date or #time type. Number Positive #number target - @positive Validates that the target number is positive. If the target number is zero or negative, it generates a validation error. Number Negative #number target - @negative Validates that the target number is negative. If the target number is zero or positive, it generates a validation error. String Not Empty #string target - @nonempty Validates that the target string is not empty. If the target string is empty, it generates a validation error. Array Not Empty #array target - @nonempty Validates that the target array is not empty. If the target array is empty, it generates a validation error. Object Not Empty #object target - @nonempty Validates that the target object is not empty. If the target object is empty, it generates a validation error."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Introduction | Json Schema",
    "keywords": "Introduction JSON, short for JavaScript Object Notation, is one of the most widely used data exchange formats that are both user-friendly and machine-readable. New JSON Schema is a practical tool for defining and validating the structure of JSON documents. It allows you to specify the expected format, data types, and constraints of JSON data. The following guides offer comprehensive details about the New JSON Schema. This document provides a list of links, each corresponding to a specific detail document available in this project. Getting Started & Installation Validation Syntax & Format Validation Directives & Pragmas Schema Specification & Grammar Data Types & Validation Functions & Validation Date & Time Patterns Build from Source Code API Reference Documentation"
  },
  "articles/quickstart.html": {
    "href": "articles/quickstart.html",
    "title": "Getting Started | Json Schema",
    "keywords": "Getting Started This guide will walk you through the essential steps to quickly get up and running with the New JSON Schema library. It is also assumed a modest familiarity with the C# language, .NET SDK, and .NET CLI (command-line interface), including basic familiarity with NuGet packages. NuGet Library Package To get started, launch your preferred IDE (such as Visual Studio, JetBrains Rider, or VS Code) and open the C# project where you intend to include this library package. Within your IDE, navigate to the NuGet package manager and search for the package by the name 'RelogicLabs.JsonSchema'. Subsequently, proceed to add or install the package to your project. Alternatively, you can use the .NET CLI to add the package to your project. Simply run the following command, replacing 1.x.x with either the latest version or your preferred version: dotnet add package RelogicLabs.JsonSchema --version 1.x.x To verify the successful integration of the library into your project, you may manually inspect your project file, typically named .csproj, using a text editor, and search for the following XML snippet within the file: <ItemGroup> <PackageReference Include=\"RelogicLabs.JsonSchema\" Version=\"1.x.x\" /> </ItemGroup> For additional information regarding this library package, you can visit the NuGet package repository page of this library here. Write a Sample to Test With all the necessary components in place, you are now ready to create a sample schema and validate a corresponding JSON against the schema. The subsequent example presents a C# class featuring a method designed for validating a sample JSON based on a provided schema. If you are working with C# 11 or above, you can enhance the code further by utilizing new language features like raw string literals, file scoped namespaces and others. using RelogicLabs.JsonSchema; namespace CSharpApplication { public class SampleSchema { public bool CheckIsValid() { var schema = @\"%title: \"\"User Profile Response\"\" %version: 1.0.0 %schema: { \"\"user\"\": { \"\"id\"\": @range(1, 10000) #integer, /*username does not allow special characters*/ \"\"username\"\": @regex(\"\"[a-z_]{3,30}\"\") #string, /*currently only one role is allowed by system*/ \"\"role\"\": \"\"user\"\" #string, \"\"isActive\"\": #boolean, //user account current status \"\"registeredAt\"\": #time, \"\"profile\"\": { \"\"firstName\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string, \"\"lastName\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string, \"\"dateOfBirth\"\": #date, \"\"age\"\": @range(18, 130) #integer, \"\"email\"\": @email #string, \"\"pictureURL\"\": @url #string, \"\"address\"\": { \"\"street\"\": @length(10, 200) #string, \"\"city\"\": @length(3, 50) #string, \"\"country\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string } #object #null } } }\"; var json = @\"{ \"\"user\"\": { \"\"id\"\": 9999, \"\"username\"\": \"\"johndoe\"\", \"\"role\"\": \"\"user\"\", \"\"isActive\"\": true, \"\"registeredAt\"\": \"\"2023-09-06T15:10:30.639Z\"\", \"\"profile\"\": { \"\"firstName\"\": \"\"John\"\", \"\"lastName\"\": \"\"Doe\"\", \"\"dateOfBirth\"\": \"\"1993-06-17\"\", \"\"age\"\": 30, \"\"email\"\": \"\"john.doe@example.com\"\", \"\"pictureURL\"\": \"\"https://example.com/picture.jpg\"\", \"\"address\"\": { \"\"street\"\": \"\"123 Some St\"\", \"\"city\"\": \"\"Some town\"\", \"\"country\"\": \"\"Some Country\"\" } } } }\"; JsonSchema jsonSchema = new(schema); return jsonSchema.IsValid(json); } } } Create Validation Errors Let's intentionally introduce a few errors by modifying the previous JSON document and then examine the validation results. To begin, we'll alter the id within the user object to a string type and observe the outcome. Additionally, we'll modify the username by inserting a space into its value, thus creating an invalid username. Below is the revised JSON representation, now containing these purposeful errors. { \"user\": { \"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"profile\": { \"firstName\": \"John\", \"lastName\": \"Doe\", \"age\": 30, \"email\": \"john.doe@example.com\", \"pictureURL\": \"https://example.com/picture.jpg\", \"address\": { \"street\": \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\" } } } } To achieve the desired outcome, please make the following changes to the preceding code. Specifically, ensure that any schema validation errors are displayed in the console. The modified code snippet that invokes the WriteError method to display the errors if validation fails is as follows: ... JsonSchema jsonSchema = new(schema); if(!jsonSchema.IsValid(json)) jsonSchema.WriteError(); ... Here is the error as displayed in the console. More specific errors will be listed first, followed by more general errors. Consequently, the specific errors will precisely pinpoint the issues within the JSON document, while the generic errors will provide contextual information about where the errors occurred. Schema (Line: 6:47) Json (Line: 3:30) [DTYP04]: Data type mismatch. Data type #integer is expected but found #string inferred by \"not number\". Schema (Line: 6:30) Json (Line: 3:30) [FUNC03]: Function @range(1, 10000) is incompatible with the target data type. Applying to a supported data type such as #number is expected but applied to an unsupported data type #string of \"not number\". Schema (Line: 8:36) Json (Line: 4:36) [REGX01]: Regex pattern does not match. String of pattern \"[a-z_]{3,30}\" is expected but found \"john doe\" that mismatches with pattern. Schema (Line: 5:28) Json (Line: 2:28) [VALD01]: Validation failed. Value {\"id\": @range(1, 10000) #integer, \"username\": @regex(\"[a-z_]{3,30}\") #string, \"role\": \"user\" #string, \"isActive\": #boolean, \"register...ing, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string} #object #null}} is expected but found {\"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"registeredAt\": \"2023-09-06T15:10:30.639Z\", \"profile\":...: \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\"}}}. Schema (Line: 4:16) Json (Line: 1:0) [VALD01]: Validation failed. Value {\"user\": {\"id\": @range(1, 10000) #integer, \"username\": @regex(\"[a-z_]{3,30}\") #string, \"role\": \"user\" #string, \"isActive\": #boolean, ...ng, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string} #object #null}}} is expected but found {\"user\": {\"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"registeredAt\": \"2023-09-06T15:10:30.639Z\", \"... \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\"}}}}. Assertion for Validation To utilize this library for test automation and API testing, you can use the following alternative code snippet to perform assertions on input JSON against a specified schema. For instance, let's examine how to assert the JSON, which has been intentionally altered to introduce some errors, against the aforementioned schema. The following demonstrates the adjusted code for asserting the JSON with errors: ... try { JsonAssert.IsValid(schema, json); } catch(Exception e) { Console.Error.WriteLine(e); } ... The following presents the printed stack trace for the preceding example. It's important to note that when using JsonAssert, it throws an exception upon encountering the first error, thus preventing the continuation of processing the rest of the schema: RelogicLabs.JsonSchema.Exceptions.JsonSchemaException: DTYP04: Data type mismatch Expected (Schema Line: 6:47): data type #integer Actual (Json Line: 3:30): found #string inferred by \"not number\" at RelogicLabs.JsonSchema.Tree.RuntimeContext.FailWith(Exception exception) at RelogicLabs.JsonSchema.Types.JNode.FailWith(Exception exception) at RelogicLabs.JsonSchema.Types.JDataType.MatchForReport(JNode node, Boolean nested) at RelogicLabs.JsonSchema.Types.JValidator.<>c__DisplayClass15_0.<MatchDataType>b__2(JDataType d) at RelogicLabs.JsonSchema.Utilities.CollectionExtensions.ForEach[T](IEnumerable`1 enumeration, Action`1 action) at RelogicLabs.JsonSchema.Types.JValidator.MatchDataType(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JObject.Match(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JObject.Match(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JRoot.Match(JNode node) at RelogicLabs.JsonSchema.JsonAssert.IsValid(String schemaExpected, String jsonActual) at CSharpApplication.SampleSchema.CheckIsValid() in /SampleSchema.cs:line 62 For more information about the schema syntax format and library functionalities, please refer to the reference documentation here."
  },
  "articles/sourcebuild.html": {
    "href": "articles/sourcebuild.html",
    "title": "Build from Source Code | Json Schema",
    "keywords": "Build from Source Code This comprehensive guide illustrates the procedures for retrieving source code from a GitHub repository, compiling the project source code into a library, and seamlessly integrating the compiled library into your project. It is essential to have a foundational understanding of the C# language, as well as a modest level of familiarity with the .NET SDK and CLI. Build the Library To get started, clone the project from the following URL using your preferred Git client (command line or GUI). You can open a terminal and enter the following Git clone command as shown below: git clone https://github.com/relogiclabs/JsonSchema-DotNet.git Next, use .NET build command dotnet build to build the project and Retrieve the DLL file, RelogicLabs.JsonSchema.dll from the bin folder. Add the Library to Your Project To integrate the library with your project, you can create a libs folder within your project directory and place the retrieved DLL file into the designated folder. Alternatively, if your IDE supports adding references, you can conveniently select the DLL from the libs folder. Alternatively, you can manually modify your project file .csproj using a text editor and include the following XML snippet: <ItemGroup> <Reference Include=\"RelogicLabs.JsonSchema\"> <HintPath>libs\\RelogicLabs.JsonSchema.dll</HintPath> </Reference> </ItemGroup> Additionally, this project has a dependency on ANTLR runtime, which you can integrate by executing the following command: dotnet add package Antlr4.Runtime.Standard --version 4.13.1 Write a Sample to Test With all the necessary components in place, you are now ready to create a sample schema and validate a corresponding JSON against the schema. The subsequent example presents a C# class featuring a method designed for validating a sample JSON based on a provided schema. If you are working with C# 11 or above, you can enhance the code further by utilizing new C# language features like raw string literals, file scoped namespaces and others. using RelogicLabs.JsonSchema; namespace CSharpApplication { public class SampleSchema { public bool CheckIsValid() { var schema = @\"%title: \"\"User Profile Response\"\" %version: 1.0.0 %schema: { \"\"user\"\": { \"\"id\"\": @range(1, 10000) #integer, /*username does not allow special characters*/ \"\"username\"\": @regex(\"\"[a-z_]{3,30}\"\") #string, /*currently only one role is allowed by system*/ \"\"role\"\": \"\"user\"\" #string, \"\"isActive\"\": #boolean, //user account current status \"\"registeredAt\"\": #time, \"\"profile\"\": { \"\"firstName\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string, \"\"lastName\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string, \"\"dateOfBirth\"\": #date, \"\"age\"\": @range(18, 130) #integer, \"\"email\"\": @email #string, \"\"pictureURL\"\": @url #string, \"\"address\"\": { \"\"street\"\": @length(10, 200) #string, \"\"city\"\": @length(3, 50) #string, \"\"country\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string } #object #null } } }\"; var json = @\"{ \"\"user\"\": { \"\"id\"\": 9999, \"\"username\"\": \"\"johndoe\"\", \"\"role\"\": \"\"user\"\", \"\"isActive\"\": true, \"\"registeredAt\"\": \"\"2023-09-06T15:10:30.639Z\"\", \"\"profile\"\": { \"\"firstName\"\": \"\"John\"\", \"\"lastName\"\": \"\"Doe\"\", \"\"dateOfBirth\"\": \"\"1993-06-17\"\", \"\"age\"\": 30, \"\"email\"\": \"\"john.doe@example.com\"\", \"\"pictureURL\"\": \"\"https://example.com/picture.jpg\"\", \"\"address\"\": { \"\"street\"\": \"\"123 Some St\"\", \"\"city\"\": \"\"Some town\"\", \"\"country\"\": \"\"Some Country\"\" } } } }\"; JsonSchema jsonSchema = new(schema); return jsonSchema.IsValid(json); } } } Create Validation Errors Let's intentionally introduce a few errors by modifying the previous JSON document and then examine the validation results. To begin, we'll alter the id within the user object to a string type and observe the outcome. Additionally, we'll modify the username by inserting a space into its value, thus creating an invalid username. Below is the revised JSON representation, now containing these purposeful errors. { \"user\": { \"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"profile\": { \"firstName\": \"John\", \"lastName\": \"Doe\", \"age\": 30, \"email\": \"john.doe@example.com\", \"pictureURL\": \"https://example.com/picture.jpg\", \"address\": { \"street\": \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\" } } } } To achieve the desired outcome, please make the following changes to the preceding code. Specifically, ensure that any schema validation errors are displayed in the console. The modified code snippet that invokes the WriteError method to display the errors if validation fails is as follows: ... JsonSchema jsonSchema = new(schema); if(!jsonSchema.IsValid(json)) jsonSchema.WriteError(); ... Here is the error as displayed in the console. More specific errors will be listed first, followed by more general errors. Consequently, the specific errors will precisely pinpoint the issues within the JSON document, while the generic errors will provide contextual information about where the errors occurred. Schema (Line: 6:47) Json (Line: 3:30) [DTYP04]: Data type mismatch. Data type #integer is expected but found #string inferred by \"not number\". Schema (Line: 6:30) Json (Line: 3:30) [FUNC03]: Function @range(1, 10000) is incompatible with the target data type. Applying to a supported data type such as #number is expected but applied to an unsupported data type #string of \"not number\". Schema (Line: 8:36) Json (Line: 4:36) [REGX01]: Regex pattern does not match. String of pattern \"[a-z_]{3,30}\" is expected but found \"john doe\" that mismatches with pattern. Schema (Line: 5:28) Json (Line: 2:28) [VALD01]: Validation failed. Value {\"id\": @range(1, 10000) #integer, \"username\": @regex(\"[a-z_]{3,30}\") #string, \"role\": \"user\" #string, \"isActive\": #boolean, \"register...ing, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string} #object #null}} is expected but found {\"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"registeredAt\": \"2023-09-06T15:10:30.639Z\", \"profile\":...: \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\"}}}. Schema (Line: 4:16) Json (Line: 1:0) [VALD01]: Validation failed. Value {\"user\": {\"id\": @range(1, 10000) #integer, \"username\": @regex(\"[a-z_]{3,30}\") #string, \"role\": \"user\" #string, \"isActive\": #boolean, ...ng, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string} #object #null}}} is expected but found {\"user\": {\"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"registeredAt\": \"2023-09-06T15:10:30.639Z\", \"... \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\"}}}}. Assertion for Validation To utilize this library for test automation and API testing, you can use the following alternative code snippet to perform assertions on input JSON against a specified schema. For instance, let's examine how to assert the JSON, which has been intentionally altered to introduce some errors, against the aforementioned schema. The following demonstrates the adjusted code for asserting the JSON with errors: ... try { JsonAssert.IsValid(schema, json); } catch(Exception e) { Console.Error.WriteLine(e); } ... The following presents the printed stack trace for the preceding example. It's important to note that when using JsonAssert, it throws an exception upon encountering the first error, thus preventing the continuation of processing the rest of the schema: RelogicLabs.JsonSchema.Exceptions.JsonSchemaException: DTYP04: Data type mismatch Expected (Schema Line: 6:47): data type #integer Actual (Json Line: 3:30): found #string inferred by \"not number\" at RelogicLabs.JsonSchema.Tree.RuntimeContext.FailWith(Exception exception) at RelogicLabs.JsonSchema.Types.JNode.FailWith(Exception exception) at RelogicLabs.JsonSchema.Types.JDataType.MatchForReport(JNode node, Boolean nested) at RelogicLabs.JsonSchema.Types.JValidator.<>c__DisplayClass15_0.<MatchDataType>b__2(JDataType d) at RelogicLabs.JsonSchema.Utilities.CollectionExtensions.ForEach[T](IEnumerable`1 enumeration, Action`1 action) at RelogicLabs.JsonSchema.Types.JValidator.MatchDataType(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JObject.Match(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JObject.Match(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JRoot.Match(JNode node) at RelogicLabs.JsonSchema.JsonAssert.IsValid(String schemaExpected, String jsonActual) at CSharpApplication.SampleSchema.CheckIsValid() in /SampleSchema.cs:line 62 For more information about the schema syntax format and library functionalities, please refer to the reference documentation here."
  },
  "articles/specification.html": {
    "href": "articles/specification.html",
    "title": "Specification | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } Specification New JSON Schema is a vocabulary that allows you to describe the structure and constraints of JSON documents. It provides a way to define rules for validating the data in a JSON document. With JSON Schema, you can ensure that your JSON data follows a specific format and adheres to certain rules. Grammar The New JSON Schema grammar is introduced through a notation similar to what is known as the McKeeman form grammar notation, which is a simplified version of the Backus-Naur form and Extended BackusNaur form. This form minimizes the usage of complex structures of meta-characters, making the grammar highly readable and easy to understand without requiring extensive prior knowledge of grammar syntax. Moreover, inside the grammar whitespace defining rules are ignored to make it clear and concise. schema schema-header-opt defines-opt schema-core defines-opt validator schema-header-opt title-opt version-opt includes-opt pragmas-opt title-opt '' '%title' ':' string version-opt '' '%version' ':' version-digits version-digits digits digits '.' version-digits includes-opt '' includes includes include includes include '%include' ':' class-identifier class-identifier identifier identifier '.' class-identifier pragmas-opt '' pragmas pragmas pragma pragmas pragma '%pragma' identifier ':' primitive defines-opt '' defines defines define defines define '%define' alias-name ':' validator-main alias-name '$' identifier schema-core '%schema' ':' validator validator validator-main alias-name validator-main value-opt functions-opt datatypes-opt this-opt value-opt '' value value primitive object array functions-opt '' functions functions function functions function function-name function-params-opt function-name '@' identifier '@' identifier '*' function-params-opt '' '(' ')' '(' function-params ')' function-params value value ',' function-params datatypes-opt '' datatypes datatypes datatype datatypes datatype datatype-name datatype-param-opt datatype-name '#' alphas '#' alphas '*' alphas alpha alphas datatype-param-opt '' '(' alias-name ')' this-opt '' '?' object '{' '}' '{' properties '}' properties property property ',' properties property string ':' validator array '[' ']' '[' elements ']' elements validator validator ',' elements primitive string number undefined 'true' 'false' 'null' undefined '!' identifier alpha alpha alpha-numerics alpha-numerics alpha-numeric alpha-numerics alpha-numeric alpha '0' . '9' alpha 'A' . 'Z' 'a' . 'z' '_' string '\"' characters '\"' characters '' character characters character '0020' . '10FFFF' - '\"' - '\\' '\\' escape escape '\"' '\\' '/' 'b' 'f' 'n' 'r' 't' 'u' hex hex hex hex hex digit 'A' . 'F' 'a' . 'f' number integer float double integer positive-integer negative-integer float integer fraction fraction '.' digits double integer fraction-opt exponent fraction-opt '' '.' digits exponent 'E' sign-opt digits 'e' sign-opt digits sign-opt '' '+' '-' positive-integer digit one-to-nine digits negative-integer '-' digit '-' one-to-nine digits digits digit digit digits digit '0' one-to-nine one-to-nine '1' . '9' To explore more about McKeeman form grammar notation and standard JSON document grammar in McKeeman form notation, please visit this page. The resource offers valuable information regarding JSON specification and implementations in different programming languages."
  },
  "articles/validation.html": {
    "href": "articles/validation.html",
    "title": "Validation Syntax | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } Validation Syntax A JSON document is a structured data format used for the exchange of information between applications. It primarily consists of two types of values: composite values and non-composite values, the latter also referred to as primitive values. Composite values in a JSON document act as containers. They can hold zero or more composite or non-composite primitive values. These composite values provide the structural framework for organizing data hierarchically within JSON documents. There are two types of composite values allowed in JSON documents: Arrays and Objects. Conversely, Non-composite values are the atomic data elements in a JSON document. They cannot contain other values within them. There are four types of primitive values supported by JSON specification: Strings, Numbers, Booleans, and Nulls. Validation Format A JSON Schema ensures the correctness and consistency of JSON documents and it also defines the structure and constraints that a JSON document must conform to. It specifies how both composite and non-composite values should be organized and validated the input document based on the rules specified in the schema document. Thus a key element of JSON Schema is the validation rule syntax, which provides the required instructions for the validation process. A validation rule is typically expressed using the following notations: 1. [Value] [Function-Set] [DataType-Set] [Optional] 2. [Undefined] [Optional] SN Component Example 1 Value 10; \"string\"; [10, 20, 30]; { \"key1\": \"value1\" } 2 Function-Set @range(1, 10); @length(5, 50) @regex(\"[A-Za-z]+\") 3 DataType-Set #string; #object #null; #number* #array 4 Value Optional 10 ?; \"string\" ?; [10, 20, 30] ? 5 Function-Set Optional @range(1, 10) ?; @length(5, 50) ? 6 DataType-Set Optional #string ?; #integer ?; #array ? 7 Function-Set DataType-Set @range(1, 10) #integer; @length(5, 10) #string 8 Function-Set DataType-Set Optional @range(1, 10) #integer ?; @length(5, 10) #string ? 9 Value Function-Set DataType-Set Optional 10 @range(1, 100) #integer ? 10 Undefined ! 11 Undefined Optional ! ? The syntax in the 9th row of the table is valid but uncommon in real-world scenarios. Since constraint function and data type provide unnecessary validation considering the validation for value is succeeded. It is a recommended practice to always define data type except in the previous scenario, even if the functions perform precise validations. This data type definition not only makes the schema more explicit for reader, but it also generates clearer validation errors that pinpoint data type mismatches if they occurred. Now, let's explore the components of this notation and their functionalities. In the context of the validation rule, Value refers to a specific input JSON value of the document. This value can be either a composite value (e.g., an object or an array) or a primitive value (e.g., a string or a number). The inclusion of Value in the validation rule is optional, meaning that you can choose whether or not to specify a particular JSON value for validation. When Value is present in the rule, it serves as a requirement, implying that the specified JSON value must match with the input JSON value of the document for the validation to succeed. If it does not match with the input value, the validation will fail. The Function-Set is an optional part of the validation rule, and it can consist of one or more function constraints. Function constraints are rules or conditions that are applied to validate the input JSON value. These functions can be of two types: Functions applied directly to the target value itself for which the validation rule is defined. Functions applied to components or items within the target value are applicable and valid only if the value is a composite JSON value. An asterisk * is used after the function name to indicate that the constraint function is applied to the nested components. The validation of the Function-Set as a whole is considered successful only if each function constraint within it succeeds, regardless of its type and application mode. SN Function Example Valid Json 1 @range(1, 10) 5; 8; 10 2 @range*(1, 10) [1, 3]; [2, 4, 6, 8, 10] 3 @length(1, 15) lorem; \"lorem ipsum\" 4 @length*(1, 15) [\"lorem\", \"lorem ipsum\"] Similar to the Function-Set, the Datatype-Set is also an optional part of the validation rule and can contain one or more data type constraints. Data type constraints define the expected data types applicable to the value itself or its nested components, depending on whether the value is composite or primitive for the input JSON value. As like function constraints data type can be of two types: Data type applied directly to the target value itself for which the validation rule is defined. Data type applied to components or items within the target value are applicable and valid only if the value is a composite JSON value. An asterisk * is used after the data type name to indicate that the data type is applied to the nested components. Validation of the Datatype-Set is deemed successful if validation is successful for one of the type 1 (or top-level) data types and one of the type 2 (nested) data types. This becomes particularly relevant in scenarios where an optional composite target value, such as an array or object, is also permitted to be null. In real-world scenarios, it's rare for a target value to exhibit multiple data types, like switching between being a number and a string. Consequently, schema rules typically do not specify multiple top-level or nested data types. SN Data Type Example Valid Json 1 #integer 5; 8; 10 2 #integer* #array [1, 3]; [2, 4, 6, 8, 10] 3 #string lorem; \"lorem ipsum\" 4 #string* #array [\"lorem\", \"lorem ipsum\"] When defining a nested type for components, it is good practice to also define the top-level type (eg. #array and #object) that not only makes the schema more convenient for readers but also generates more straightforward validation errors to the point if they occurred, but it is optional. The Optional specifier, denoted as ?, signifies that the presence of the target value is optional within the input JSON document. When Optional is specified, it indicates that the value may or may not be present. If it is absent, no validation is performed for that specific target value, and the JSON document is considered valid. However, if the target value is present, the validation rule must succeed for the document to be considered valid and conform to Schema. Failure to meet the validation rule renders the JSON document invalid. In the absence of the Optional specifier, the target JSON value must be present in the provided input JSON document for validation to succeed. In instances where no validation rule (or no components of the validation rule) is explicitly defined for a target input JSON value, the use of the undefined marker ! signifies that any valid JSON value is acceptable for the target. This allows more flexibility in JSON data validation for specific cases."
  },
  "index.html": {
    "href": "index.html",
    "title": "A New JSON Schema | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } A New JSON Schema A JSON Schema is crucial for making communication, interoperability, validation, testing, documentation, and specification seamless. All of this combined contributes to better maintenance and evolution of data-driven applications and systems. For a comprehensive overview of the roles and uses of JSON Schema in modern web applications, we invite you to explore our dedicated post available here. Design Goals The traditional standard JSON Schema rigorously follows the conventional JSON structure, which unfortunately comes at the expense of simplicity, conciseness, and readability. Our goal is to develop a new JSON Schema that promotes these essential aspects that were previously missing. This new schema is simple, lucid, easy to grasp, and doesn't require much prior knowledge to understand it. It also offers a shallow learning curve for both reading and writing. Additionally, its simplicity and conciseness allow us and machines to read-write more efficiently. Moreover, a large set of constraint data types and functions within the core schema promotes the precise definition of JSON documents, significantly reducing the potential for communication gaps among collaborators. Furthermore, its inherent extensibility not only facilitates the test automation process in API testing but also simplifies the integrations of new constraints and functionalities to meet the diverse requirements of modern web services. Basic Example Let's explore an example of our schema for a typical JSON API response containing information about a user profile or account. The schema is very self-explanatory and thus almost no prior knowledge is required to understand the schema and the JSON responses specified by this schema. %title: \"User Profile Response\" %version: 1.0.0 %schema: { \"user\": { \"id\": @range(1, 10000) #integer, /*username does not allow special characters*/ \"username\": @regex(\"[a-z_]{3,30}\") #string, /*currently only one role is allowed by system*/ \"role\": \"user\" #string, \"isActive\": #boolean, //user account current status \"registeredAt\": #time, \"profile\": { \"firstName\": @regex(\"[A-Za-z ]{3,50}\") #string, \"lastName\": @regex(\"[A-Za-z ]{3,50}\") #string, \"dateOfBirth\": #date, \"age\": @range(18, 130) #integer, \"email\": @email #string, \"pictureURL\": @url #string, \"address\": { \"street\": @length(10, 200) #string, \"city\": @length(3, 50) #string, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string } #object #null } } } In the above example, two types of constraints are used: constraint functions (also referred to as validation functions, such as @range(1, 10000)) and constraint data types (also referred to as validation data types, such as #integer). All constraint functions begin with the @ symbol, while all constraint data types start with #. C-style comments are also supported within the schema. In this example, address can be null (like an optional input for users) and if it is null then no constraints of address are applicable. The following JSON is one of the examples that will be successfully validated against the above schema. To start your journey with the JSON validation library, please consult the documentation available here. { \"user\": { \"id\": 1234, \"username\": \"johndoe\", \"role\": \"user\", \"isActive\": true, \"registeredAt\": \"2023-09-06T15:10:30.639Z\", \"profile\": { \"firstName\": \"John\", \"lastName\": \"Doe\", \"dateOfBirth\": \"1993-06-17\", \"age\": 30, \"email\": \"john.doe@example.com\", \"pictureURL\": \"https://example.com/picture.jpg\", \"address\": { \"street\": \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\" } } } } Extended Example The next example represents an expanded version of the previous one, which brings more complexity. To effectively construct such schemas with multiple layers of nested structures, it's beneficial to have a fundamental understanding of this schema format. While the syntax may seem difficult at first, it becomes straightforward once you have a basic understanding of it. For more detailed information, reference documentation is available here. %title: \"Extended User Profile Dashboard API Response\" %version: 2.0.0 %include: RelogicLabs.JsonSchema.Tests.Positive.ExternalFunctions, RelogicLabs.JsonSchema.Tests %pragma IgnoreUndefinedProperties: true %define $post: { \"id\": @range(1, 1000) #integer, \"title\": @length(10, 100) #string, \"content\": @length(30, 1000) #string, \"tags\": $tags } #object %define $product: { \"id\": @length(2, 10) @regex(\"[a-z][a-z0-9]+\") #string, \"name\": @length(5, 30) #string, \"brand\": @length(5, 30) #string, \"price\": @range(0.1, 1000000), \"inStock\": #boolean, \"specs\": { \"cpu\": @length(5, 30) #string, \"ram\": @regex(\"[0-9]{1,2}GB\") #string, \"storage\": @regex(\"[0-9]{1,4}GB (SSD|HDD)\") #string } #object #null } %define $tags: @length(1, 10) #string*($tag) #array %define $tag: @length(3, 20) @regex(\"[A-Za-z_]+\") #string %schema: { \"user\": { \"id\": @range(1, 10000) #integer, /*username does not allow special characters*/ \"username\": @regex(\"[a-z_]{3,30}\") #string, \"role\": @enum(\"user\", \"admin\") #string, \"isActive\": #boolean, //user account current status \"registeredAt\": @time(\"DD-MM-YYYY hh:mm:ss\") #string, \"profile\": { \"firstName\": @regex(\"[A-Za-z]{3,50}\") #string, \"lastName\": @regex(\"[A-Za-z]{3,50}\") #string, \"dateOfBirth\": @date(\"DD-MM-YYYY\") #string, \"age\": @range(18, 128) #integer, \"email\": @email #string, \"pictureURL\": @url #string, \"address\": { \"street\": @length(10, 200) #string, \"city\": @length(3, 50) #string, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string } #object #null, \"hobbies\": !? }, \"posts\": @length(0, 1000) #object*($post) #array, \"preferences\": { \"theme\": @enum(\"light\", \"dark\") #string, \"fontSize\": @range(9, 24) #integer, \"autoSave\": #boolean } }, \"products\": #object*($product) #array, \"weather\": { \"temperature\": @range(-50.0, 60.0) #float, \"isCloudy\": #boolean } } The subsequent JSON sample is an illustrative example that successfully validates against the expanded schema mentioned earlier. Within this example, recurring JSON structures appear that can be validated by defining components or nested functions and data types. Besides, reusing simple component definitions, you can achieve a clear and concise schema when validating large JSON with repetitive structures instead of duplicating or referring to various structures across the schema. This improves the overall readability and maintainability of the schema. { \"user\": { \"id\": 1234, \"username\": \"johndoe\", \"role\": \"admin\", \"isActive\": true, \"registeredAt\": \"06-09-2023 15:10:30\", \"profile\": { \"firstName\": \"John\", \"lastName\": \"Doe\", \"dateOfBirth\": \"17-06-1993\", \"age\": 30, \"email\": \"john.doe@example.com\", \"pictureURL\": \"https://example.com/picture.jpg\", \"address\": { \"street\": \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\" } }, \"posts\": [ { \"id\": 1, \"title\": \"Introduction to JSON\", \"content\": \"JSON (JavaScript Object Notation) is a lightweight data interchange format...\", \"tags\": [ \"JSON\", \"tutorial\", \"data\" ] }, { \"id\": 2, \"title\": \"Working with JSON in C#\", \"content\": \"C# provides built-in support for working with JSON...\", \"tags\": [ \"CSharp\", \"JSON\", \"tutorial\" ] }, { \"id\": 3, \"title\": \"Introduction to JSON Schema\", \"content\": \"A JSON schema defines the structure and data types of JSON objects...\", \"tags\": [ \"Schema\", \"JSON\", \"tutorial\" ] } ], \"preferences\": { \"theme\": \"dark\", \"fontSize\": 14, \"autoSave\": true } }, \"products\": [ { \"id\": \"p1\", \"name\": \"Smartphone\", \"brand\": \"TechGiant\", \"price\": 599.99, \"inStock\": true, \"specs\": null }, { \"id\": \"p2\", \"name\": \"Laptop\", \"brand\": \"SuperTech\", \"price\": 1299.99, \"inStock\": false, \"specs\": { \"cpu\": \"Intel i11\", \"ram\": \"11GB\", \"storage\": \"11GB SSD\" } } ], \"weather\": { \"temperature\": 25.5, \"isCloudy\": true, \"conditions\": null } } For more information about the schema syntax format and library functionalities, please refer to the reference documentation here."
  }
}