{
  "api/RelogicLabs.JsonSchema.Collections.IIndexMap-2.html": {
    "href": "api/RelogicLabs.JsonSchema.Collections.IIndexMap-2.html",
    "title": "Interface IIndexMap<TK, TV> | Json Schema",
    "keywords": "Interface IIndexMap<TK, TV> Namespace RelogicLabs.JsonSchema.Collections Assembly RelogicLabs.JsonSchema.dll public interface IIndexMap<TK, TV> : IList<TV>, ICollection<TV>, IEnumerable<TV>, IEnumerable where TK : notnull where TV : IKeyed<TK> Type Parameters TK TV Inherited Members IList<TV>.IndexOf(TV) IList<TV>.Insert(int, TV) IList<TV>.RemoveAt(int) IList<TV>.this[int] ICollection<TV>.Add(TV) ICollection<TV>.Clear() ICollection<TV>.Contains(TV) ICollection<TV>.CopyTo(TV[], int) ICollection<TV>.Remove(TV) ICollection<TV>.Count ICollection<TV>.IsReadOnly IEnumerable<TV>.GetEnumerator() Properties this[TK] TV this[TK key] { get; } Parameters key TK Property Value TV Keys IEnumerable<TK> Keys { get; } Property Value IEnumerable<TK> Values IEnumerable<TV> Values { get; } Property Value IEnumerable<TV> Methods AsReadOnly() IIndexMap<TK, TV> AsReadOnly() Returns IIndexMap<TK, TV> TryGetValue(TK, out TV?) bool TryGetValue(TK key, out TV? value) Parameters key TK value TV Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Collections.IKeyed-1.html": {
    "href": "api/RelogicLabs.JsonSchema.Collections.IKeyed-1.html",
    "title": "Interface IKeyed<TK> | Json Schema",
    "keywords": "Interface IKeyed<TK> Namespace RelogicLabs.JsonSchema.Collections Assembly RelogicLabs.JsonSchema.dll public interface IKeyed<out TK> Type Parameters TK Properties Key TK Key { get; } Property Value TK"
  },
  "api/RelogicLabs.JsonSchema.Collections.html": {
    "href": "api/RelogicLabs.JsonSchema.Collections.html",
    "title": "Namespace RelogicLabs.JsonSchema.Collections | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Collections Interfaces IIndexMap<TK, TV> IKeyed<TK>"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.ClassInstantiationException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.ClassInstantiationException.html",
    "title": "Class ClassInstantiationException | Json Schema",
    "keywords": "Class ClassInstantiationException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class ClassInstantiationException : CommonException, ISerializable Inheritance object Exception CommonException ClassInstantiationException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ClassInstantiationException(ErrorDetail) public ClassInstantiationException(ErrorDetail detail) Parameters detail ErrorDetail ClassInstantiationException(ErrorDetail, Exception?) public ClassInstantiationException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception ClassInstantiationException(string, string) public ClassInstantiationException(string code, string message) Parameters code string message string ClassInstantiationException(string, string, Exception?) public ClassInstantiationException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.ClassNotFoundException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.ClassNotFoundException.html",
    "title": "Class ClassNotFoundException | Json Schema",
    "keywords": "Class ClassNotFoundException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class ClassNotFoundException : CommonException, ISerializable Inheritance object Exception CommonException ClassNotFoundException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ClassNotFoundException(ErrorDetail) public ClassNotFoundException(ErrorDetail detail) Parameters detail ErrorDetail ClassNotFoundException(ErrorDetail, Exception?) public ClassNotFoundException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception ClassNotFoundException(string, string) public ClassNotFoundException(string code, string message) Parameters code string message string ClassNotFoundException(string, string, Exception?) public ClassNotFoundException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.CommonException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.CommonException.html",
    "title": "Class CommonException | Json Schema",
    "keywords": "Class CommonException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class CommonException : Exception, ISerializable Inheritance object Exception CommonException Implements ISerializable Derived ClassInstantiationException ClassNotFoundException DateTimeLexerException DefinitionNotFoundException DuplicateDefinitionException DuplicateIncludeException DuplicatePragmaException DuplicatePropertyKeyException FunctionNotFoundException InvalidDataTypeException InvalidDateTimeException InvalidFunctionException InvalidIncludeException InvalidPragmaValueException JsonLexerException JsonParserException JsonSchemaException MisplacedOptionalException NoValueReceivedException PragmaNotFoundException ReceiverNotFoundException SchemaLexerException SchemaParserException Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors CommonException(ErrorDetail) protected CommonException(ErrorDetail detail) Parameters detail ErrorDetail CommonException(ErrorDetail, Exception?) protected CommonException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception CommonException(string, string) protected CommonException(string code, string message) Parameters code string message string CommonException(string, string, Exception?) protected CommonException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception Properties Code public string Code { get; } Property Value string Methods GetAttribute(string) public string? GetAttribute(string name) Parameters name string Returns string SetAttribute(string, string) public void SetAttribute(string name, string value) Parameters name string value string"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DateTimeLexerException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DateTimeLexerException.html",
    "title": "Class DateTimeLexerException | Json Schema",
    "keywords": "Class DateTimeLexerException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DateTimeLexerException : CommonException, ISerializable Inheritance object Exception CommonException DateTimeLexerException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DateTimeLexerException(string, string) public DateTimeLexerException(string code, string message) Parameters code string message string DateTimeLexerException(string, string, Exception?) public DateTimeLexerException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DefinitionNotFoundException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DefinitionNotFoundException.html",
    "title": "Class DefinitionNotFoundException | Json Schema",
    "keywords": "Class DefinitionNotFoundException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DefinitionNotFoundException : CommonException, ISerializable Inheritance object Exception CommonException DefinitionNotFoundException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DefinitionNotFoundException(ErrorDetail) public DefinitionNotFoundException(ErrorDetail detail) Parameters detail ErrorDetail DefinitionNotFoundException(ErrorDetail, Exception?) public DefinitionNotFoundException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception DefinitionNotFoundException(string, string) public DefinitionNotFoundException(string code, string message) Parameters code string message string DefinitionNotFoundException(string, string, Exception?) public DefinitionNotFoundException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DuplicateDefinitionException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DuplicateDefinitionException.html",
    "title": "Class DuplicateDefinitionException | Json Schema",
    "keywords": "Class DuplicateDefinitionException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DuplicateDefinitionException : CommonException, ISerializable Inheritance object Exception CommonException DuplicateDefinitionException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DuplicateDefinitionException(ErrorDetail) public DuplicateDefinitionException(ErrorDetail detail) Parameters detail ErrorDetail DuplicateDefinitionException(ErrorDetail, Exception?) public DuplicateDefinitionException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception DuplicateDefinitionException(string, string) public DuplicateDefinitionException(string code, string message) Parameters code string message string DuplicateDefinitionException(string, string, Exception?) public DuplicateDefinitionException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DuplicateIncludeException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DuplicateIncludeException.html",
    "title": "Class DuplicateIncludeException | Json Schema",
    "keywords": "Class DuplicateIncludeException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DuplicateIncludeException : CommonException, ISerializable Inheritance object Exception CommonException DuplicateIncludeException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DuplicateIncludeException(ErrorDetail) public DuplicateIncludeException(ErrorDetail detail) Parameters detail ErrorDetail DuplicateIncludeException(ErrorDetail, Exception?) public DuplicateIncludeException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception DuplicateIncludeException(string, string) public DuplicateIncludeException(string code, string message) Parameters code string message string DuplicateIncludeException(string, string, Exception?) public DuplicateIncludeException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DuplicatePragmaException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DuplicatePragmaException.html",
    "title": "Class DuplicatePragmaException | Json Schema",
    "keywords": "Class DuplicatePragmaException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DuplicatePragmaException : CommonException, ISerializable Inheritance object Exception CommonException DuplicatePragmaException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DuplicatePragmaException(ErrorDetail) public DuplicatePragmaException(ErrorDetail detail) Parameters detail ErrorDetail DuplicatePragmaException(ErrorDetail, Exception?) public DuplicatePragmaException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception DuplicatePragmaException(string, string) public DuplicatePragmaException(string code, string message) Parameters code string message string DuplicatePragmaException(string, string, Exception?) public DuplicatePragmaException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.DuplicatePropertyKeyException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.DuplicatePropertyKeyException.html",
    "title": "Class DuplicatePropertyKeyException | Json Schema",
    "keywords": "Class DuplicatePropertyKeyException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class DuplicatePropertyKeyException : CommonException, ISerializable Inheritance object Exception CommonException DuplicatePropertyKeyException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DuplicatePropertyKeyException(ErrorDetail) public DuplicatePropertyKeyException(ErrorDetail detail) Parameters detail ErrorDetail DuplicatePropertyKeyException(ErrorDetail, Exception?) public DuplicatePropertyKeyException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception DuplicatePropertyKeyException(string, string) public DuplicatePropertyKeyException(string code, string message) Parameters code string message string DuplicatePropertyKeyException(string, string, Exception?) public DuplicatePropertyKeyException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.FunctionNotFoundException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.FunctionNotFoundException.html",
    "title": "Class FunctionNotFoundException | Json Schema",
    "keywords": "Class FunctionNotFoundException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class FunctionNotFoundException : CommonException, ISerializable Inheritance object Exception CommonException FunctionNotFoundException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors FunctionNotFoundException(ErrorDetail) public FunctionNotFoundException(ErrorDetail detail) Parameters detail ErrorDetail FunctionNotFoundException(ErrorDetail, Exception?) public FunctionNotFoundException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception FunctionNotFoundException(string, string) public FunctionNotFoundException(string code, string message) Parameters code string message string FunctionNotFoundException(string, string, Exception?) public FunctionNotFoundException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidDataTypeException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidDataTypeException.html",
    "title": "Class InvalidDataTypeException | Json Schema",
    "keywords": "Class InvalidDataTypeException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidDataTypeException : CommonException, ISerializable Inheritance object Exception CommonException InvalidDataTypeException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidDataTypeException(ErrorDetail) public InvalidDataTypeException(ErrorDetail detail) Parameters detail ErrorDetail InvalidDataTypeException(ErrorDetail, Exception?) public InvalidDataTypeException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception InvalidDataTypeException(string, string) public InvalidDataTypeException(string code, string message) Parameters code string message string InvalidDataTypeException(string, string, Exception?) public InvalidDataTypeException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidDateTimeException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidDateTimeException.html",
    "title": "Class InvalidDateTimeException | Json Schema",
    "keywords": "Class InvalidDateTimeException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidDateTimeException : CommonException, ISerializable Inheritance object Exception CommonException InvalidDateTimeException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidDateTimeException(ErrorDetail) public InvalidDateTimeException(ErrorDetail detail) Parameters detail ErrorDetail InvalidDateTimeException(ErrorDetail, Exception?) public InvalidDateTimeException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception InvalidDateTimeException(string, string) public InvalidDateTimeException(string code, string message) Parameters code string message string InvalidDateTimeException(string, string, Exception?) public InvalidDateTimeException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidFunctionException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidFunctionException.html",
    "title": "Class InvalidFunctionException | Json Schema",
    "keywords": "Class InvalidFunctionException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidFunctionException : CommonException, ISerializable Inheritance object Exception CommonException InvalidFunctionException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidFunctionException(ErrorDetail) public InvalidFunctionException(ErrorDetail detail) Parameters detail ErrorDetail InvalidFunctionException(ErrorDetail, Exception?) public InvalidFunctionException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception InvalidFunctionException(string, string) public InvalidFunctionException(string code, string message) Parameters code string message string InvalidFunctionException(string, string, Exception?) public InvalidFunctionException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidIncludeException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidIncludeException.html",
    "title": "Class InvalidIncludeException | Json Schema",
    "keywords": "Class InvalidIncludeException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidIncludeException : CommonException, ISerializable Inheritance object Exception CommonException InvalidIncludeException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidIncludeException(ErrorDetail) public InvalidIncludeException(ErrorDetail detail) Parameters detail ErrorDetail InvalidIncludeException(ErrorDetail, Exception?) public InvalidIncludeException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception InvalidIncludeException(string, string) public InvalidIncludeException(string code, string message) Parameters code string message string InvalidIncludeException(string, string, Exception?) public InvalidIncludeException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.InvalidPragmaValueException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.InvalidPragmaValueException.html",
    "title": "Class InvalidPragmaValueException | Json Schema",
    "keywords": "Class InvalidPragmaValueException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class InvalidPragmaValueException : CommonException, ISerializable Inheritance object Exception CommonException InvalidPragmaValueException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidPragmaValueException(ErrorDetail) public InvalidPragmaValueException(ErrorDetail detail) Parameters detail ErrorDetail InvalidPragmaValueException(ErrorDetail, Exception?) public InvalidPragmaValueException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception InvalidPragmaValueException(string, string) public InvalidPragmaValueException(string code, string message) Parameters code string message string InvalidPragmaValueException(string, string, Exception?) public InvalidPragmaValueException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.JsonLexerException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.JsonLexerException.html",
    "title": "Class JsonLexerException | Json Schema",
    "keywords": "Class JsonLexerException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class JsonLexerException : CommonException, ISerializable Inheritance object Exception CommonException JsonLexerException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors JsonLexerException(string, string) public JsonLexerException(string code, string message) Parameters code string message string JsonLexerException(string, string, Exception?) public JsonLexerException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.JsonParserException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.JsonParserException.html",
    "title": "Class JsonParserException | Json Schema",
    "keywords": "Class JsonParserException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class JsonParserException : CommonException, ISerializable Inheritance object Exception CommonException JsonParserException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors JsonParserException(string, string) public JsonParserException(string code, string message) Parameters code string message string JsonParserException(string, string, Exception?) public JsonParserException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.JsonSchemaException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.JsonSchemaException.html",
    "title": "Class JsonSchemaException | Json Schema",
    "keywords": "Class JsonSchemaException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class JsonSchemaException : CommonException, ISerializable Inheritance object Exception CommonException JsonSchemaException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors JsonSchemaException(ErrorDetail, ExpectedDetail, ActualDetail, Exception?) public JsonSchemaException(ErrorDetail error, ExpectedDetail expected, ActualDetail actual, Exception? innerException = null) Parameters error ErrorDetail expected ExpectedDetail actual ActualDetail innerException Exception Properties Actual public ActualDetail Actual { get; } Property Value ActualDetail Error public ErrorDetail Error { get; } Property Value ErrorDetail Expected public ExpectedDetail Expected { get; } Property Value ExpectedDetail"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.MisplacedOptionalException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.MisplacedOptionalException.html",
    "title": "Class MisplacedOptionalException | Json Schema",
    "keywords": "Class MisplacedOptionalException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class MisplacedOptionalException : CommonException, ISerializable Inheritance object Exception CommonException MisplacedOptionalException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors MisplacedOptionalException(ErrorDetail) public MisplacedOptionalException(ErrorDetail detail) Parameters detail ErrorDetail MisplacedOptionalException(ErrorDetail, Exception?) public MisplacedOptionalException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception MisplacedOptionalException(string, string) public MisplacedOptionalException(string code, string message) Parameters code string message string MisplacedOptionalException(string, string, Exception?) public MisplacedOptionalException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.NoValueReceivedException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.NoValueReceivedException.html",
    "title": "Class NoValueReceivedException | Json Schema",
    "keywords": "Class NoValueReceivedException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class NoValueReceivedException : CommonException, ISerializable Inheritance object Exception CommonException NoValueReceivedException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors NoValueReceivedException(ErrorDetail) public NoValueReceivedException(ErrorDetail detail) Parameters detail ErrorDetail NoValueReceivedException(ErrorDetail, Exception?) public NoValueReceivedException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception NoValueReceivedException(string, string) public NoValueReceivedException(string code, string message) Parameters code string message string NoValueReceivedException(string, string, Exception?) public NoValueReceivedException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.PragmaNotFoundException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.PragmaNotFoundException.html",
    "title": "Class PragmaNotFoundException | Json Schema",
    "keywords": "Class PragmaNotFoundException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class PragmaNotFoundException : CommonException, ISerializable Inheritance object Exception CommonException PragmaNotFoundException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors PragmaNotFoundException(ErrorDetail) public PragmaNotFoundException(ErrorDetail detail) Parameters detail ErrorDetail PragmaNotFoundException(ErrorDetail, Exception?) public PragmaNotFoundException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception PragmaNotFoundException(string, string) public PragmaNotFoundException(string code, string message) Parameters code string message string PragmaNotFoundException(string, string, Exception?) public PragmaNotFoundException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.ReceiverNotFoundException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.ReceiverNotFoundException.html",
    "title": "Class ReceiverNotFoundException | Json Schema",
    "keywords": "Class ReceiverNotFoundException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class ReceiverNotFoundException : CommonException, ISerializable Inheritance object Exception CommonException ReceiverNotFoundException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ReceiverNotFoundException(ErrorDetail) public ReceiverNotFoundException(ErrorDetail detail) Parameters detail ErrorDetail ReceiverNotFoundException(ErrorDetail, Exception?) public ReceiverNotFoundException(ErrorDetail detail, Exception? innerException) Parameters detail ErrorDetail innerException Exception ReceiverNotFoundException(string, string) public ReceiverNotFoundException(string code, string message) Parameters code string message string ReceiverNotFoundException(string, string, Exception?) public ReceiverNotFoundException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.SchemaLexerException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.SchemaLexerException.html",
    "title": "Class SchemaLexerException | Json Schema",
    "keywords": "Class SchemaLexerException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class SchemaLexerException : CommonException, ISerializable Inheritance object Exception CommonException SchemaLexerException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors SchemaLexerException(string, string) public SchemaLexerException(string code, string message) Parameters code string message string SchemaLexerException(string, string, Exception?) public SchemaLexerException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.SchemaParserException.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.SchemaParserException.html",
    "title": "Class SchemaParserException | Json Schema",
    "keywords": "Class SchemaParserException Namespace RelogicLabs.JsonSchema.Exceptions Assembly RelogicLabs.JsonSchema.dll public class SchemaParserException : CommonException, ISerializable Inheritance object Exception CommonException SchemaParserException Implements ISerializable Inherited Members CommonException.Code CommonException.GetAttribute(string) CommonException.SetAttribute(string, string) Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors SchemaParserException(string, string) public SchemaParserException(string code, string message) Parameters code string message string SchemaParserException(string, string, Exception?) public SchemaParserException(string code, string message, Exception? innerException) Parameters code string message string innerException Exception"
  },
  "api/RelogicLabs.JsonSchema.Exceptions.html": {
    "href": "api/RelogicLabs.JsonSchema.Exceptions.html",
    "title": "Namespace RelogicLabs.JsonSchema.Exceptions | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Exceptions Classes ClassInstantiationException ClassNotFoundException CommonException DateTimeLexerException DefinitionNotFoundException DuplicateDefinitionException DuplicateIncludeException DuplicatePragmaException DuplicatePropertyKeyException FunctionNotFoundException InvalidDataTypeException InvalidDateTimeException InvalidFunctionException InvalidIncludeException InvalidPragmaValueException JsonLexerException JsonParserException JsonSchemaException MisplacedOptionalException NoValueReceivedException PragmaNotFoundException ReceiverNotFoundException SchemaLexerException SchemaParserException"
  },
  "api/RelogicLabs.JsonSchema.Functions.CoreFunctions.html": {
    "href": "api/RelogicLabs.JsonSchema.Functions.CoreFunctions.html",
    "title": "Class CoreFunctions | Json Schema",
    "keywords": "Class CoreFunctions Namespace RelogicLabs.JsonSchema.Functions Assembly RelogicLabs.JsonSchema.dll public sealed class CoreFunctions : FunctionBase Inheritance object FunctionBase CoreFunctions Inherited Members FunctionBase.Runtime FunctionBase.Function object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors CoreFunctions(RuntimeContext) public CoreFunctions(RuntimeContext runtime) Parameters runtime RuntimeContext Methods After(JDateTime, JString) public bool After(JDateTime target, JString reference) Parameters target JDateTime reference JString Returns bool Before(JDateTime, JString) public bool Before(JDateTime target, JString reference) Parameters target JDateTime reference JString Returns bool Date(JString, JString) public bool Date(JString target, JString pattern) Parameters target JString pattern JString Returns bool Elements(JArray, params JNode[]) public bool Elements(JArray target, params JNode[] items) Parameters target JArray items JNode[] Returns bool Email(JString) public bool Email(JString target) Parameters target JString Returns bool End(JDateTime, JString) public bool End(JDateTime target, JString reference) Parameters target JDateTime reference JString Returns bool Enum(JNumber, params JNumber[]) public bool Enum(JNumber target, params JNumber[] items) Parameters target JNumber items JNumber[] Returns bool Enum(JString, params JString[]) public bool Enum(JString target, params JString[] items) Parameters target JString items JString[] Returns bool Keys(JObject, params JString[]) public bool Keys(JObject target, params JString[] items) Parameters target JObject items JString[] Returns bool Length(JArray, JInteger) public bool Length(JArray target, JInteger length) Parameters target JArray length JInteger Returns bool Length(JArray, JInteger, JInteger) public bool Length(JArray target, JInteger minimum, JInteger maximum) Parameters target JArray minimum JInteger maximum JInteger Returns bool Length(JArray, JInteger, JUndefined) public bool Length(JArray target, JInteger minimum, JUndefined undefined) Parameters target JArray minimum JInteger undefined JUndefined Returns bool Length(JArray, JUndefined, JInteger) public bool Length(JArray target, JUndefined undefined, JInteger maximum) Parameters target JArray undefined JUndefined maximum JInteger Returns bool Length(JObject, JInteger) public bool Length(JObject target, JInteger length) Parameters target JObject length JInteger Returns bool Length(JObject, JInteger, JInteger) public bool Length(JObject target, JInteger minimum, JInteger maximum) Parameters target JObject minimum JInteger maximum JInteger Returns bool Length(JObject, JInteger, JUndefined) public bool Length(JObject target, JInteger minimum, JUndefined undefined) Parameters target JObject minimum JInteger undefined JUndefined Returns bool Length(JObject, JUndefined, JInteger) public bool Length(JObject target, JUndefined undefined, JInteger maximum) Parameters target JObject undefined JUndefined maximum JInteger Returns bool Length(JString, JInteger) public bool Length(JString target, JInteger length) Parameters target JString length JInteger Returns bool Length(JString, JInteger, JInteger) public bool Length(JString target, JInteger minimum, JInteger maximum) Parameters target JString minimum JInteger maximum JInteger Returns bool Length(JString, JInteger, JUndefined) public bool Length(JString target, JInteger minimum, JUndefined undefined) Parameters target JString minimum JInteger undefined JUndefined Returns bool Length(JString, JUndefined, JInteger) public bool Length(JString target, JUndefined undefined, JInteger maximum) Parameters target JString undefined JUndefined maximum JInteger Returns bool Maximum(JNumber, JNumber) public bool Maximum(JNumber target, JNumber maximum) Parameters target JNumber maximum JNumber Returns bool Maximum(JNumber, JNumber, JBoolean) public bool Maximum(JNumber target, JNumber maximum, JBoolean exclusive) Parameters target JNumber maximum JNumber exclusive JBoolean Returns bool Minimum(JNumber, JNumber) public bool Minimum(JNumber target, JNumber minimum) Parameters target JNumber minimum JNumber Returns bool Minimum(JNumber, JNumber, JBoolean) public bool Minimum(JNumber target, JNumber minimum, JBoolean exclusive) Parameters target JNumber minimum JNumber exclusive JBoolean Returns bool Negative(JNumber) public bool Negative(JNumber target) Parameters target JNumber Returns bool Negative(JNumber, JNumber) public bool Negative(JNumber target, JNumber reference) Parameters target JNumber reference JNumber Returns bool Nonempty(JArray) public bool Nonempty(JArray target) Parameters target JArray Returns bool Nonempty(JObject) public bool Nonempty(JObject target) Parameters target JObject Returns bool Nonempty(JString) public bool Nonempty(JString target) Parameters target JString Returns bool Phone(JString) public bool Phone(JString target) Parameters target JString Returns bool Positive(JNumber) public bool Positive(JNumber target) Parameters target JNumber Returns bool Positive(JNumber, JNumber) public bool Positive(JNumber target, JNumber reference) Parameters target JNumber reference JNumber Returns bool Range(JDateTime, JString, JString) public bool Range(JDateTime target, JString start, JString end) Parameters target JDateTime start JString end JString Returns bool Range(JDateTime, JString, JUndefined) public bool Range(JDateTime target, JString start, JUndefined end) Parameters target JDateTime start JString end JUndefined Returns bool Range(JDateTime, JUndefined, JString) public bool Range(JDateTime target, JUndefined start, JString end) Parameters target JDateTime start JUndefined end JString Returns bool Range(JNumber, JNumber, JNumber) public bool Range(JNumber target, JNumber minimum, JNumber maximum) Parameters target JNumber minimum JNumber maximum JNumber Returns bool Range(JNumber, JNumber, JUndefined) public bool Range(JNumber target, JNumber minimum, JUndefined undefined) Parameters target JNumber minimum JNumber undefined JUndefined Returns bool Range(JNumber, JUndefined, JNumber) public bool Range(JNumber target, JUndefined undefined, JNumber maximum) Parameters target JNumber undefined JUndefined maximum JNumber Returns bool Regex(JString, JString) public bool Regex(JString target, JString pattern) Parameters target JString pattern JString Returns bool Start(JDateTime, JString) public bool Start(JDateTime target, JString reference) Parameters target JDateTime reference JString Returns bool Time(JString, JString) public bool Time(JString target, JString pattern) Parameters target JString pattern JString Returns bool Url(JString) public bool Url(JString target) Parameters target JString Returns bool Url(JString, JString) public bool Url(JString target, JString scheme) Parameters target JString scheme JString Returns bool Values(JObject, params JNode[]) public bool Values(JObject target, params JNode[] items) Parameters target JObject items JNode[] Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Functions.FunctionBase.html": {
    "href": "api/RelogicLabs.JsonSchema.Functions.FunctionBase.html",
    "title": "Class FunctionBase | Json Schema",
    "keywords": "Class FunctionBase Namespace RelogicLabs.JsonSchema.Functions Assembly RelogicLabs.JsonSchema.dll public abstract class FunctionBase Inheritance object FunctionBase Derived CoreFunctions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FunctionBase(RuntimeContext) protected FunctionBase(RuntimeContext runtime) Parameters runtime RuntimeContext Properties Function public JFunction Function { get; set; } Property Value JFunction Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext Methods FailWith(Exception) protected bool FailWith(Exception exception) Parameters exception Exception Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Functions.FutureValidator.html": {
    "href": "api/RelogicLabs.JsonSchema.Functions.FutureValidator.html",
    "title": "Delegate FutureValidator | Json Schema",
    "keywords": "Delegate FutureValidator Namespace RelogicLabs.JsonSchema.Functions Assembly RelogicLabs.JsonSchema.dll public delegate bool FutureValidator() Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Functions.html": {
    "href": "api/RelogicLabs.JsonSchema.Functions.html",
    "title": "Namespace RelogicLabs.JsonSchema.Functions | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Functions Classes CoreFunctions FunctionBase Delegates FutureValidator"
  },
  "api/RelogicLabs.JsonSchema.JsonAssert.html": {
    "href": "api/RelogicLabs.JsonSchema.JsonAssert.html",
    "title": "Class JsonAssert | Json Schema",
    "keywords": "Class JsonAssert Namespace RelogicLabs.JsonSchema Assembly RelogicLabs.JsonSchema.dll Provides assertion functionalities to validate JSON document against a Schema or JSON. public class JsonAssert Inheritance object JsonAssert Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors JsonAssert(string) Initializes a new instance of the JsonAssert class for the specified Schema string. public JsonAssert(string schema) Parameters schema string A Schema string for validation or conformation. JsonAssert(string, TreeType) Initializes a new instance of the JsonAssert class for the specified expected string which can be either a Schema or a JSON representation. public JsonAssert(string expected, TreeType type) Parameters expected string An expected Schema or JSON string for validation or conformation. type TreeType The type of string provided by expected, indicating whether it represents a Schema or JSON. Use SCHEMA_TREE for Schema and JSON_TREE for JSON. Properties ExpectedTree public IDataTree ExpectedTree { get; } Property Value IDataTree Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext Methods AreEqual(string, string) Tests if the provided JSON strings are logically equivalent, meaning their structural composition and internal data are identical. If the JSON strings are not equivalent, an exception is thrown. public static void AreEqual(string expected, string actual) Parameters expected string The expected JSON to compare. actual string The actual JSON to compare. IsValid(string) Tests whether the input JSON string conforms to the expected Schema or JSON specified in the JsonAssert constructor. public void IsValid(string json) Parameters json string The actual JSON to conform or validate. IsValid(string, string) Tests whether the specified JSON string conforms to the given Schema string and throws an exception if the JSON string does not conform to the Schema. public static void IsValid(string schema, string json) Parameters schema string The expected Schema to conform or validate. json string The actual JSON to conform or validate."
  },
  "api/RelogicLabs.JsonSchema.JsonSchema.html": {
    "href": "api/RelogicLabs.JsonSchema.JsonSchema.html",
    "title": "Class JsonSchema | Json Schema",
    "keywords": "Class JsonSchema Namespace RelogicLabs.JsonSchema Assembly RelogicLabs.JsonSchema.dll Provides Schema validation functionalities for JSON document. public class JsonSchema Inheritance object JsonSchema Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors JsonSchema(string) Initializes a new instance of the JsonSchema class for the specified Schema string. public JsonSchema(string schema) Parameters schema string A Schema string for validation or conformation. Properties Exceptions public ExceptionRegistry Exceptions { get; } Property Value ExceptionRegistry Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext SchemaTree public SchemaTree SchemaTree { get; } Property Value SchemaTree Methods IsValid(string) Indicates whether the input JSON string conforms to the Schema specified in the JsonSchema constructor. public bool IsValid(string json) Parameters json string The JSON string to conform or validate with Schema. Returns bool true if the JSON string conforms to the Schema; otherwise, false. IsValid(string, string) Indicates whether the input JSON string conforms to the given Schema string. public static bool IsValid(string schema, string json) Parameters schema string The Schema string to conform or validate. json string The JSON string to conform or validate. Returns bool true if the JSON string conforms to the Schema; otherwise, false. WriteError() Writes error messages that occur during Schema validation process, to the standard error stream. public void WriteError()"
  },
  "api/RelogicLabs.JsonSchema.Message.ActualDetail.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.ActualDetail.html",
    "title": "Class ActualDetail | Json Schema",
    "keywords": "Class ActualDetail Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public sealed class ActualDetail : ContextDetail Inheritance object ContextDetail ActualDetail Inherited Members ContextDetail.Context ContextDetail.Message ContextDetail.Location object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ActualDetail(Context, string) public ActualDetail(Context context, string message) Parameters context Context message string ActualDetail(JNode, string) public ActualDetail(JNode node, string message) Parameters node JNode message string"
  },
  "api/RelogicLabs.JsonSchema.Message.ContextDetail.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.ContextDetail.html",
    "title": "Class ContextDetail | Json Schema",
    "keywords": "Class ContextDetail Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public abstract class ContextDetail Inheritance object ContextDetail Derived ActualDetail ExpectedDetail Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ContextDetail(Context, string) protected ContextDetail(Context context, string message) Parameters context Context message string ContextDetail(JNode, string) protected ContextDetail(JNode node, string message) Parameters node JNode message string Properties Context public Context Context { get; } Property Value Context Location public Location Location { get; } Property Value Location Message public string Message { get; } Property Value string"
  },
  "api/RelogicLabs.JsonSchema.Message.ErrorDetail.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.ErrorDetail.html",
    "title": "Class ErrorDetail | Json Schema",
    "keywords": "Class ErrorDetail Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public sealed class ErrorDetail Inheritance object ErrorDetail Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ErrorDetail(string, string) public ErrorDetail(string code, string message) Parameters code string message string Properties Code public string Code { get; } Property Value string Message public string Message { get; } Property Value string"
  },
  "api/RelogicLabs.JsonSchema.Message.ExpectedDetail.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.ExpectedDetail.html",
    "title": "Class ExpectedDetail | Json Schema",
    "keywords": "Class ExpectedDetail Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public sealed class ExpectedDetail : ContextDetail Inheritance object ContextDetail ExpectedDetail Inherited Members ContextDetail.Context ContextDetail.Message ContextDetail.Location object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ExpectedDetail(Context, string) public ExpectedDetail(Context context, string message) Parameters context Context message string ExpectedDetail(JNode, string) public ExpectedDetail(JNode node, string message) Parameters node JNode message string"
  },
  "api/RelogicLabs.JsonSchema.Message.MessageFormatter.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.MessageFormatter.html",
    "title": "Class MessageFormatter | Json Schema",
    "keywords": "Class MessageFormatter Namespace RelogicLabs.JsonSchema.Message Assembly RelogicLabs.JsonSchema.dll public abstract class MessageFormatter Inheritance object MessageFormatter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields JsonAssertion public static readonly MessageFormatter JsonAssertion Field Value MessageFormatter SchemaAssertion public static readonly MessageFormatter SchemaAssertion Field Value MessageFormatter SchemaValidation public static readonly MessageFormatter SchemaValidation Field Value MessageFormatter Properties Actual public string Actual { get; } Property Value string Expected public string Expected { get; } Property Value string OutlineLength public int OutlineLength { get; set; } Property Value int Summary public string Summary { get; } Property Value string Methods CreateOutline(string) public string CreateOutline(string target) Parameters target string Returns string"
  },
  "api/RelogicLabs.JsonSchema.Message.html": {
    "href": "api/RelogicLabs.JsonSchema.Message.html",
    "title": "Namespace RelogicLabs.JsonSchema.Message | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Message Classes ActualDetail ContextDetail ErrorDetail ExpectedDetail MessageFormatter"
  },
  "api/RelogicLabs.JsonSchema.Time.DateTimeType.html": {
    "href": "api/RelogicLabs.JsonSchema.Time.DateTimeType.html",
    "title": "Class DateTimeType | Json Schema",
    "keywords": "Class DateTimeType Namespace RelogicLabs.JsonSchema.Time Assembly RelogicLabs.JsonSchema.dll public sealed class DateTimeType Inheritance object DateTimeType Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Fields DATE_TYPE public static readonly DateTimeType DATE_TYPE Field Value DateTimeType TIME_TYPE public static readonly DateTimeType TIME_TYPE Field Value DateTimeType Properties Name public string Name { get; } Property Value string Type public JsonType Type { get; } Property Value JsonType Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Time.JsonDateTime.html": {
    "href": "api/RelogicLabs.JsonSchema.Time.JsonDateTime.html",
    "title": "Class JsonDateTime | Json Schema",
    "keywords": "Class JsonDateTime Namespace RelogicLabs.JsonSchema.Time Assembly RelogicLabs.JsonSchema.dll public class JsonDateTime Inheritance object JsonDateTime Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Fields UNSET public const int UNSET = -1000 Field Value int Properties Day public int Day { get; } Property Value int Fraction public int Fraction { get; } Property Value int Hour public int Hour { get; } Property Value int Minute public int Minute { get; } Property Value int Month public int Month { get; } Property Value int Second public int Second { get; } Property Value int Type public DateTimeType Type { get; } Property Value DateTimeType UtcOffset public JsonUtcOffset UtcOffset { get; } Property Value JsonUtcOffset Year public int Year { get; } Property Value int Methods Compare(JsonDateTime) public int Compare(JsonDateTime other) Parameters other JsonDateTime Returns int GetDayOfWeek() public DayOfWeek? GetDayOfWeek() Returns DayOfWeek? ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Time.JsonUtcOffset.html": {
    "href": "api/RelogicLabs.JsonSchema.Time.JsonUtcOffset.html",
    "title": "Class JsonUtcOffset | Json Schema",
    "keywords": "Class JsonUtcOffset Namespace RelogicLabs.JsonSchema.Time Assembly RelogicLabs.JsonSchema.dll public class JsonUtcOffset Inheritance object JsonUtcOffset Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors JsonUtcOffset() public JsonUtcOffset() JsonUtcOffset(int, int) public JsonUtcOffset(int hour, int minute) Parameters hour int minute int Properties Hour public int Hour { get; } Property Value int Minute public int Minute { get; } Property Value int Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Time.html": {
    "href": "api/RelogicLabs.JsonSchema.Time.html",
    "title": "Namespace RelogicLabs.JsonSchema.Time | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Time Classes DateTimeType JsonDateTime JsonUtcOffset"
  },
  "api/RelogicLabs.JsonSchema.Tree.Context.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.Context.html",
    "title": "Class Context | Json Schema",
    "keywords": "Class Context Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class Context Inheritance object Context Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Context(ParserRuleContext, RuntimeContext) public Context(ParserRuleContext parser, RuntimeContext runtime) Parameters parser ParserRuleContext runtime RuntimeContext Properties Parser public ParserRuleContext Parser { get; } Property Value ParserRuleContext Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext Methods GetLocation() public Location GetLocation() Returns Location GetText() public string GetText() Returns string"
  },
  "api/RelogicLabs.JsonSchema.Tree.ExceptionRegistry.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.ExceptionRegistry.html",
    "title": "Class ExceptionRegistry | Json Schema",
    "keywords": "Class ExceptionRegistry Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public class ExceptionRegistry : IEnumerable<Exception>, IEnumerable Inheritance object ExceptionRegistry Implements IEnumerable<Exception> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Count public int Count { get; } Property Value int CutoffLimit public int CutoffLimit { get; set; } Property Value int ThrowException public bool ThrowException { get; set; } Property Value bool Methods Clear() public void Clear() GetEnumerator() Returns an enumerator that iterates through the collection. public IEnumerator<Exception> GetEnumerator() Returns IEnumerator<Exception> An enumerator that can be used to iterate through the collection."
  },
  "api/RelogicLabs.JsonSchema.Tree.FunctionRegistry.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.FunctionRegistry.html",
    "title": "Class FunctionRegistry | Json Schema",
    "keywords": "Class FunctionRegistry Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class FunctionRegistry Inheritance object FunctionRegistry Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Methods AddClass(JInclude) public JInclude AddClass(JInclude include) Parameters include JInclude Returns JInclude AddClass(string, Context?) public void AddClass(string className, Context? context = null) Parameters className string context Context InvokeFunction(JFunction, JNode) public bool InvokeFunction(JFunction function, JNode target) Parameters function JFunction target JNode Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Tree.IDataTree.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.IDataTree.html",
    "title": "Interface IDataTree | Json Schema",
    "keywords": "Interface IDataTree Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public interface IDataTree Properties Root JRoot Root { get; } Property Value JRoot Runtime RuntimeContext Runtime { get; } Property Value RuntimeContext Type TreeType Type { get; } Property Value TreeType Methods Match(IDataTree) bool Match(IDataTree dataTree) Parameters dataTree IDataTree Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Tree.JsonTree.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.JsonTree.html",
    "title": "Class JsonTree | Json Schema",
    "keywords": "Class JsonTree Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class JsonTree : IDataTree Inheritance object JsonTree Implements IDataTree Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors JsonTree(RuntimeContext, string) public JsonTree(RuntimeContext runtime, string input) Parameters runtime RuntimeContext input string Properties Root public JRoot Root { get; } Property Value JRoot Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext Type public TreeType Type { get; } Property Value TreeType Methods Match(IDataTree) public bool Match(IDataTree dataTree) Parameters dataTree IDataTree Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Tree.Location.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.Location.html",
    "title": "Struct Location | Json Schema",
    "keywords": "Struct Location Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public readonly record struct Location : IEquatable<Location> Implements IEquatable<Location> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Location(int, int) public Location(int Line, int Column) Parameters Line int Column int Properties Column public int Column { get; init; } Property Value int Line public int Line { get; init; } Property Value int Methods From(IToken) public static Location From(IToken token) Parameters token IToken Returns Location ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/RelogicLabs.JsonSchema.Tree.PragmaRegistry.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.PragmaRegistry.html",
    "title": "Class PragmaRegistry | Json Schema",
    "keywords": "Class PragmaRegistry Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class PragmaRegistry : IEnumerable<KeyValuePair<string, JPragma>>, IEnumerable Inheritance object PragmaRegistry Implements IEnumerable<KeyValuePair<string, JPragma>> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties DateDataTypeFormat public string DateDataTypeFormat { get; } Property Value string FloatingPointTolerance public double FloatingPointTolerance { get; } Property Value double IgnoreObjectPropertyOrder public bool IgnoreObjectPropertyOrder { get; } Property Value bool IgnoreUndefinedProperties public bool IgnoreUndefinedProperties { get; } Property Value bool TimeDataTypeFormat public string TimeDataTypeFormat { get; } Property Value string Methods AddPragma(JPragma) public JPragma AddPragma(JPragma pragma) Parameters pragma JPragma Returns JPragma GetEnumerator() Returns an enumerator that iterates through the collection. public IEnumerator<KeyValuePair<string, JPragma>> GetEnumerator() Returns IEnumerator<KeyValuePair<string, JPragma>> An enumerator that can be used to iterate through the collection. GetPragma(string) public JPragma? GetPragma(string name) Parameters name string Returns JPragma GetPragmaValue<T>(string) public T GetPragmaValue<T>(string name) Parameters name string Returns T Type Parameters T"
  },
  "api/RelogicLabs.JsonSchema.Tree.ReceiverRegistry.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.ReceiverRegistry.html",
    "title": "Class ReceiverRegistry | Json Schema",
    "keywords": "Class ReceiverRegistry Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public class ReceiverRegistry : IEnumerable<KeyValuePair<JReceiver, List<JNode>>>, IEnumerable Inheritance object ReceiverRegistry Implements IEnumerable<KeyValuePair<JReceiver, List<JNode>>> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Clear() public void Clear() Fetch(JReceiver) public List<JNode>? Fetch(JReceiver receiver) Parameters receiver JReceiver Returns List<JNode> GetEnumerator() Returns an enumerator that iterates through the collection. public IEnumerator<KeyValuePair<JReceiver, List<JNode>>> GetEnumerator() Returns IEnumerator<KeyValuePair<JReceiver, List<JNode>>> An enumerator that can be used to iterate through the collection. Receive(IEnumerable<JReceiver>, JNode) public void Receive(IEnumerable<JReceiver> receivers, JNode node) Parameters receivers IEnumerable<JReceiver> node JNode Register(IEnumerable<JReceiver>) public void Register(IEnumerable<JReceiver> receivers) Parameters receivers IEnumerable<JReceiver>"
  },
  "api/RelogicLabs.JsonSchema.Tree.RuntimeContext.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.RuntimeContext.html",
    "title": "Class RuntimeContext | Json Schema",
    "keywords": "Class RuntimeContext Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class RuntimeContext Inheritance object RuntimeContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Definitions public Dictionary<JAlias, JValidator> Definitions { get; } Property Value Dictionary<JAlias, JValidator> Exceptions public ExceptionRegistry Exceptions { get; } Property Value ExceptionRegistry Functions public FunctionRegistry Functions { get; } Property Value FunctionRegistry Pragmas public PragmaRegistry Pragmas { get; } Property Value PragmaRegistry Receivers public ReceiverRegistry Receivers { get; } Property Value ReceiverRegistry Storage public Dictionary<string, object> Storage { get; } Property Value Dictionary<string, object> Validators public Dictionary<string, FutureValidator> Validators { get; } Property Value Dictionary<string, FutureValidator> Methods AddDefinition(JDefinition) public JDefinition AddDefinition(JDefinition definition) Parameters definition JDefinition Returns JDefinition AddValidator(FutureValidator) public bool AddValidator(FutureValidator validator) Parameters validator FutureValidator Returns bool Clear() public void Clear()"
  },
  "api/RelogicLabs.JsonSchema.Tree.SchemaTree.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.SchemaTree.html",
    "title": "Class SchemaTree | Json Schema",
    "keywords": "Class SchemaTree Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public sealed class SchemaTree : IDataTree Inheritance object SchemaTree Implements IDataTree Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors SchemaTree(RuntimeContext, string) public SchemaTree(RuntimeContext runtime, string input) Parameters runtime RuntimeContext input string Properties Root public JRoot Root { get; } Property Value JRoot Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext Type public TreeType Type { get; } Property Value TreeType Methods Match(IDataTree) public bool Match(IDataTree dataTree) Parameters dataTree IDataTree Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Tree.TreeType.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.TreeType.html",
    "title": "Class TreeType | Json Schema",
    "keywords": "Class TreeType Namespace RelogicLabs.JsonSchema.Tree Assembly RelogicLabs.JsonSchema.dll public class TreeType Inheritance object TreeType Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Fields JSON_TREE public static readonly TreeType JSON_TREE Field Value TreeType SCHEMA_TREE public static readonly TreeType SCHEMA_TREE Field Value TreeType Properties Name public string Name { get; } Property Value string Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Tree.html": {
    "href": "api/RelogicLabs.JsonSchema.Tree.html",
    "title": "Namespace RelogicLabs.JsonSchema.Tree | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Tree Classes Context ExceptionRegistry FunctionRegistry JsonTree PragmaRegistry ReceiverRegistry RuntimeContext SchemaTree TreeType Structs Location Interfaces IDataTree"
  },
  "api/RelogicLabs.JsonSchema.Types.IDerived.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.IDerived.html",
    "title": "Interface IDerived | Json Schema",
    "keywords": "Interface IDerived Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public interface IDerived Properties Derived JNode? Derived { get; } Property Value JNode"
  },
  "api/RelogicLabs.JsonSchema.Types.IJsonType.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.IJsonType.html",
    "title": "Interface IJsonType | Json Schema",
    "keywords": "Interface IJsonType Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public interface IJsonType Properties Node JNode Node { get; } Property Value JNode Type JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.INestedMode.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.INestedMode.html",
    "title": "Interface INestedMode | Json Schema",
    "keywords": "Interface INestedMode Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public interface INestedMode Properties Nested bool Nested { get; } Property Value bool"
  },
  "api/RelogicLabs.JsonSchema.Types.IPragmaValue-1.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.IPragmaValue-1.html",
    "title": "Interface IPragmaValue<T> | Json Schema",
    "keywords": "Interface IPragmaValue<T> Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public interface IPragmaValue<out T> Type Parameters T Properties Value T Value { get; } Property Value T"
  },
  "api/RelogicLabs.JsonSchema.Types.JAlias.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JAlias.html",
    "title": "Class JAlias | Json Schema",
    "keywords": "Class JAlias Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JAlias : JLeaf Inheritance object JNode JLeaf JAlias Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Name public string Name { get; } Property Value string Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JArray.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JArray.html",
    "title": "Class JArray | Json Schema",
    "keywords": "Class JArray Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JArray : JComposite, IJsonType Inheritance object JNode JBranch JComposite JArray Implements IJsonType Inherited Members JComposite.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties Components public override IList<JNode> Components { get; } Property Value IList<JNode> Elements public IList<JNode> Elements { get; } Property Value IList<JNode> Type public override JsonType Type { get; } Property Value JsonType Methods Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JBoolean.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JBoolean.html",
    "title": "Class JBoolean | Json Schema",
    "keywords": "Class JBoolean Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JBoolean : JPrimitive, IJsonType, IPragmaValue<bool> Inheritance object JNode JLeaf JPrimitive JBoolean Implements IJsonType IPragmaValue<bool> Inherited Members JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Value public bool Value { get; } Property Value bool Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator bool(JBoolean) public static implicit operator bool(JBoolean @bool) Parameters bool JBoolean Returns bool"
  },
  "api/RelogicLabs.JsonSchema.Types.JBranch.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JBranch.html",
    "title": "Class JBranch | Json Schema",
    "keywords": "Class JBranch Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JBranch : JNode Inheritance object JNode JBranch Derived JComposite JDataType JFunction JProperty JValidator Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object)"
  },
  "api/RelogicLabs.JsonSchema.Types.JComposite.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JComposite.html",
    "title": "Class JComposite | Json Schema",
    "keywords": "Class JComposite Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JComposite : JBranch, IJsonType Inheritance object JNode JBranch JComposite Implements IJsonType Derived JArray JObject Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Components public abstract IList<JNode> Components { get; } Property Value IList<JNode> Node public JNode Node { get; } Property Value JNode Type public virtual JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.JDataType.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDataType.html",
    "title": "Class JDataType | Json Schema",
    "keywords": "Class JDataType Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JDataType : JBranch, INestedMode Inheritance object JNode JBranch JDataType Implements INestedMode Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Alias public JAlias? Alias { get; } Property Value JAlias JsonType public JsonType JsonType { get; } Property Value JsonType Nested public bool Nested { get; } Property Value bool Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. ToString(bool) public string ToString(bool baseForm) Parameters baseForm bool Returns string"
  },
  "api/RelogicLabs.JsonSchema.Types.JDate.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDate.html",
    "title": "Class JDate | Json Schema",
    "keywords": "Class JDate Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JDate : JDateTime, IJsonType, IDerived, IPragmaValue<string> Inheritance object JNode JLeaf JPrimitive JString JDateTime JDate Implements IJsonType IDerived IPragmaValue<string> Inherited Members JDateTime.DateTime JString.Value JString.Derived JString.Match(JNode) JString.Equals(object) JString.GetHashCode() JString.ToString() JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.JDateTime.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDateTime.html",
    "title": "Class JDateTime | Json Schema",
    "keywords": "Class JDateTime Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JDateTime : JString, IJsonType, IDerived, IPragmaValue<string> Inheritance object JNode JLeaf JPrimitive JString JDateTime Implements IJsonType IDerived IPragmaValue<string> Derived JDate JTime Inherited Members JString.Value JString.Derived JString.Match(JNode) JString.Equals(object) JString.GetHashCode() JString.ToString() JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties DateTime public JsonDateTime DateTime { get; } Property Value JsonDateTime Type public override JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.JDefinition.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDefinition.html",
    "title": "Class JDefinition | Json Schema",
    "keywords": "Class JDefinition Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JDefinition : JDirective Inheritance object JNode JDirective JDefinition Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties Alias public JAlias Alias { get; } Property Value JAlias Validator public JValidator Validator { get; } Property Value JValidator Methods ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JDirective.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDirective.html",
    "title": "Class JDirective | Json Schema",
    "keywords": "Class JDirective Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JDirective : JNode Inheritance object JNode JDirective Derived JDefinition JInclude JPragma JTitle JVersion Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Methods Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false."
  },
  "api/RelogicLabs.JsonSchema.Types.JDouble.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JDouble.html",
    "title": "Class JDouble | Json Schema",
    "keywords": "Class JDouble Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JDouble : JNumber, IJsonType, IPragmaValue<double> Inheritance object JNode JLeaf JPrimitive JNumber JDouble Implements IJsonType IPragmaValue<double> Inherited Members JNumber.Compare(double) JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Value public double Value { get; } Property Value double Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToDouble() protected override double ToDouble() Returns double ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator double(JDouble) public static implicit operator double(JDouble node) Parameters node JDouble Returns double"
  },
  "api/RelogicLabs.JsonSchema.Types.JFloat.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JFloat.html",
    "title": "Class JFloat | Json Schema",
    "keywords": "Class JFloat Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JFloat : JNumber, IJsonType, IPragmaValue<double> Inheritance object JNode JLeaf JPrimitive JNumber JFloat Implements IJsonType IPragmaValue<double> Inherited Members JNumber.Compare(double) JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Value public double Value { get; } Property Value double Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToDouble() protected override double ToDouble() Returns double ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator double(JFloat) public static implicit operator double(JFloat node) Parameters node JFloat Returns double"
  },
  "api/RelogicLabs.JsonSchema.Types.JFunction.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JFunction.html",
    "title": "Class JFunction | Json Schema",
    "keywords": "Class JFunction Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JFunction : JBranch, INestedMode Inheritance object JNode JBranch JFunction Implements INestedMode Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties Arguments public IList<JNode> Arguments { get; } Property Value IList<JNode> Name public string Name { get; } Property Value string Nested public bool Nested { get; } Property Value bool Methods Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. ToString(bool) public string ToString(bool baseForm) Parameters baseForm bool Returns string"
  },
  "api/RelogicLabs.JsonSchema.Types.JInclude.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JInclude.html",
    "title": "Class JInclude | Json Schema",
    "keywords": "Class JInclude Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JInclude : JDirective Inheritance object JNode JDirective JInclude Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties ClassName public string ClassName { get; } Property Value string Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JInteger.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JInteger.html",
    "title": "Class JInteger | Json Schema",
    "keywords": "Class JInteger Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JInteger : JNumber, IJsonType, IPragmaValue<long> Inheritance object JNode JLeaf JPrimitive JNumber JInteger Implements IJsonType IPragmaValue<long> Inherited Members JNumber.Compare(double) JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Value public long Value { get; } Property Value long Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToDouble() protected override double ToDouble() Returns double ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator double(JInteger) public static implicit operator double(JInteger node) Parameters node JInteger Returns double implicit operator long(JInteger) public static implicit operator long(JInteger node) Parameters node JInteger Returns long"
  },
  "api/RelogicLabs.JsonSchema.Types.JLeaf.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JLeaf.html",
    "title": "Class JLeaf | Json Schema",
    "keywords": "Class JLeaf Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JLeaf : JNode Inheritance object JNode JLeaf Derived JAlias JPrimitive JReceiver JUndefined Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object)"
  },
  "api/RelogicLabs.JsonSchema.Types.JNode.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JNode.html",
    "title": "Class JNode | Json Schema",
    "keywords": "Class JNode Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JNode Inheritance object JNode Derived JBranch JDirective JLeaf JRoot Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Children public virtual IEnumerable<JNode> Children { get; } Property Value IEnumerable<JNode> Context public Context Context { get; } Property Value Context Parent public virtual JNode? Parent { get; } Property Value JNode Runtime public RuntimeContext Runtime { get; } Property Value RuntimeContext Methods GetOutline() Returns an abbreviated outline version of the string obtained from the ToString() method of the specified length from OutlineLength and replaces a portion of the string with ellipses to match the specified length; otherwise, returns the string unmodified. public virtual string GetOutline() Returns string An abbreviated outline version of the ToString() string. Match(JNode) Determines whether the specified node matches with the current node. public abstract bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JNull.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JNull.html",
    "title": "Class JNull | Json Schema",
    "keywords": "Class JNull Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JNull : JPrimitive, IJsonType Inheritance object JNode JLeaf JPrimitive JNull Implements IJsonType Inherited Members JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JNumber.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JNumber.html",
    "title": "Class JNumber | Json Schema",
    "keywords": "Class JNumber Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JNumber : JPrimitive, IJsonType Inheritance object JNode JLeaf JPrimitive JNumber Implements IJsonType Derived JDouble JFloat JInteger Inherited Members JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType Methods Compare(double) public int Compare(double other) Parameters other double Returns int Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. ToDouble() protected abstract double ToDouble() Returns double Operators implicit operator double(JNumber) public static implicit operator double(JNumber number) Parameters number JNumber Returns double"
  },
  "api/RelogicLabs.JsonSchema.Types.JObject.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JObject.html",
    "title": "Class JObject | Json Schema",
    "keywords": "Class JObject Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JObject : JComposite, IJsonType Inheritance object JNode JBranch JComposite JObject Implements IJsonType Inherited Members JComposite.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Components public override IList<JNode> Components { get; } Property Value IList<JNode> Properties public IIndexMap<string, JProperty> Properties { get; } Property Value IIndexMap<string, JProperty> Type public override JsonType Type { get; } Property Value JsonType Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JPragma.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JPragma.html",
    "title": "Class JPragma | Json Schema",
    "keywords": "Class JPragma Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JPragma : JDirective Inheritance object JNode JDirective JPragma Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Name public string Name { get; } Property Value string Value public JPrimitive Value { get; } Property Value JPrimitive Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JPrimitive.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JPrimitive.html",
    "title": "Class JPrimitive | Json Schema",
    "keywords": "Class JPrimitive Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public abstract class JPrimitive : JLeaf, IJsonType Inheritance object JNode JLeaf JPrimitive Implements IJsonType Derived JBoolean JNull JNumber JString Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.Match(JNode) JNode.ToString() JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Node public JNode Node { get; } Property Value JNode Type public virtual JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.JProperty.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JProperty.html",
    "title": "Class JProperty | Json Schema",
    "keywords": "Class JProperty Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JProperty : JBranch, IKeyed<string> Inheritance object JNode JBranch JProperty Implements IKeyed<string> Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Key public string Key { get; } Property Value string Value public JNode Value { get; } Property Value JNode Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JReceiver.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JReceiver.html",
    "title": "Class JReceiver | Json Schema",
    "keywords": "Class JReceiver Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JReceiver : JLeaf Inheritance object JNode JLeaf JReceiver Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Name public string Name { get; } Property Value string Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. GetValueCount() public int GetValueCount() Returns int GetValueNode<T>() public T GetValueNode<T>() where T : JNode Returns T Type Parameters T GetValueNodes<T>() public IList<T> GetValueNodes<T>() where T : JNode Returns IList<T> Type Parameters T Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JRoot.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JRoot.html",
    "title": "Class JRoot | Json Schema",
    "keywords": "Class JRoot Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JRoot : JNode Inheritance object JNode JRoot Inherited Members JNode.Context JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties Definitions public IList<JDefinition>? Definitions { get; } Property Value IList<JDefinition> Includes public IList<JInclude>? Includes { get; } Property Value IList<JInclude> Parent public override JNode Parent { get; } Property Value JNode Pragmas public IList<JPragma>? Pragmas { get; } Property Value IList<JPragma> Title public JTitle? Title { get; } Property Value JTitle Value public JNode Value { get; } Property Value JNode Version public JVersion? Version { get; } Property Value JVersion Methods Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JString.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JString.html",
    "title": "Class JString | Json Schema",
    "keywords": "Class JString Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public class JString : JPrimitive, IJsonType, IDerived, IPragmaValue<string> Inheritance object JNode JLeaf JPrimitive JString Implements IJsonType IDerived IPragmaValue<string> Derived JDateTime Inherited Members JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Derived public JNode? Derived { get; set; } Property Value JNode Type public override JsonType Type { get; } Property Value JsonType Value public string Value { get; } Property Value string Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object. Operators implicit operator string(JString) public static implicit operator string(JString node) Parameters node JString Returns string"
  },
  "api/RelogicLabs.JsonSchema.Types.JTime.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JTime.html",
    "title": "Class JTime | Json Schema",
    "keywords": "Class JTime Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JTime : JDateTime, IJsonType, IDerived, IPragmaValue<string> Inheritance object JNode JLeaf JPrimitive JString JDateTime JTime Implements IJsonType IDerived IPragmaValue<string> Inherited Members JDateTime.DateTime JString.Value JString.Derived JString.Match(JNode) JString.Equals(object) JString.GetHashCode() JString.ToString() JPrimitive.Node JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Type public override JsonType Type { get; } Property Value JsonType"
  },
  "api/RelogicLabs.JsonSchema.Types.JTitle.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JTitle.html",
    "title": "Class JTitle | Json Schema",
    "keywords": "Class JTitle Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JTitle : JDirective Inheritance object JNode JDirective JTitle Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties Title public string Title { get; } Property Value string Methods ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JUndefined.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JUndefined.html",
    "title": "Class JUndefined | Json Schema",
    "keywords": "Class JUndefined Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JUndefined : JLeaf Inheritance object JNode JLeaf JUndefined Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JValidator.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JValidator.html",
    "title": "Class JValidator | Json Schema",
    "keywords": "Class JValidator Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JValidator : JBranch Inheritance object JNode JBranch JValidator Inherited Members JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties DataTypes public IList<JDataType> DataTypes { get; } Property Value IList<JDataType> Functions public IList<JFunction> Functions { get; } Property Value IList<JFunction> Optional public bool Optional { get; } Property Value bool Receivers public IList<JReceiver> Receivers { get; } Property Value IList<JReceiver> Value public JNode? Value { get; } Property Value JNode Methods Match(JNode) Determines whether the specified node matches with the current node. public override bool Match(JNode node) Parameters node JNode The node to compare with the current node. Returns bool true if the specified node matches with the current node; otherwise, false. ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JVersion.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JVersion.html",
    "title": "Class JVersion | Json Schema",
    "keywords": "Class JVersion Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public sealed class JVersion : JDirective Inheritance object JNode JDirective JVersion Inherited Members JDirective.Match(JNode) JNode.Context JNode.Parent JNode.Children JNode.Runtime JNode.GetOutline() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Properties Version public string Version { get; } Property Value string Methods ToString() Returns a JSON string that represents the current object. public override string ToString() Returns string A JSON string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.JsonType.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.JsonType.html",
    "title": "Class JsonType | Json Schema",
    "keywords": "Class JsonType Namespace RelogicLabs.JsonSchema.Types Assembly RelogicLabs.JsonSchema.dll public class JsonType Inheritance object JsonType Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Fields ANY public static readonly JsonType ANY Field Value JsonType ARRAY public static readonly JsonType ARRAY Field Value JsonType BOOLEAN public static readonly JsonType BOOLEAN Field Value JsonType COMPOSITE public static readonly JsonType COMPOSITE Field Value JsonType DATE public static readonly JsonType DATE Field Value JsonType DATETIME public static readonly JsonType DATETIME Field Value JsonType DOUBLE public static readonly JsonType DOUBLE Field Value JsonType FLOAT public static readonly JsonType FLOAT Field Value JsonType INTEGER public static readonly JsonType INTEGER Field Value JsonType NULL public static readonly JsonType NULL Field Value JsonType NUMBER public static readonly JsonType NUMBER Field Value JsonType OBJECT public static readonly JsonType OBJECT Field Value JsonType PRIMITIVE public static readonly JsonType PRIMITIVE Field Value JsonType STRING public static readonly JsonType STRING Field Value JsonType TIME public static readonly JsonType TIME Field Value JsonType Properties Name public string Name { get; } Property Value string Type public Type Type { get; } Property Value Type Methods Match(JNode, out string) public bool Match(JNode node, out string error) Parameters node JNode error string Returns bool ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/RelogicLabs.JsonSchema.Types.html": {
    "href": "api/RelogicLabs.JsonSchema.Types.html",
    "title": "Namespace RelogicLabs.JsonSchema.Types | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema.Types Classes JAlias JArray JBoolean JBranch JComposite JDataType JDate JDateTime JDefinition JDirective JDouble JFloat JFunction JInclude JInteger JLeaf JNode JNull JNumber JObject JPragma JPrimitive JProperty JReceiver JRoot JString JTime JTitle JUndefined JValidator JVersion JsonType Interfaces IDerived IJsonType INestedMode IPragmaValue<T>"
  },
  "api/RelogicLabs.JsonSchema.html": {
    "href": "api/RelogicLabs.JsonSchema.html",
    "title": "Namespace RelogicLabs.JsonSchema | Json Schema",
    "keywords": "Namespace RelogicLabs.JsonSchema Classes JsonAssert Provides assertion functionalities to validate JSON document against a Schema or JSON. JsonSchema Provides Schema validation functionalities for JSON document."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation | Json Schema",
    "keywords": "API Documentation The API documentation is auto-generated from both source code and source code comments. For broader understandings, exploring the source code itself often reveals even more valuable insights and details. To access and explore the source code, please visit the GitHub repository here."
  },
  "articles/components.html": {
    "href": "articles/components.html",
    "title": "Reusable Components | Json Schema",
    "keywords": "Reusable Components A schema component, also known as a reusable schema fragment or sub-schema, plays a vital role in improving readability, reducing redundancy, and organizing the structure of a Schema document. In JSON validation, a schema component or fragment defines a validation rule that can be recursively composed of multiple nested validation rules, collectively specifying the expected and valid format of a JSON structure. These schema components are utilized as extensions of data type validation, as basic data types have a very limited ability to validate the internal structure of a composite JSON value or construct. Therefore, a data type is parameterized with a component to validate the internal structure of such composite JSON constructs. Moreover, schema components can be referenced from any other part of the Schema document, effectively reducing redundancy and enhancing reusability. The following example defines a simple schema component named $component where the validation rule describes an object structure with two key-value pairs: %define $component: { \"key1\": #integer, \"key2\": #string } A composite JSON construct is created by combining multiple values as defined by the JSON specification. These nested values can range from simple, like numbers or strings, to more complex, such as arrays or objects. While simple nested values of a composite construct can be validated using only nested data types and functions, handling hierarchical composite constructs with multiple layers of nested structures requires defining schema components. The second and third rows of the following table illustrate how the component validates the value associated with the data type for which it is used as a parameter. If the associated data type is direct, the component validates the target value itself. Conversely, if the associated data type is nested, the component validates each of the nested values comprising the composite target construct. SN Component Example Valid Json 1 @range*(1, 10) @length(5) #integer* #array [1, 3, 5, 8, 10] 2 %define $cmp: @range*(1, 10) #integer* %schema: @length(5) #array($cmp) [1, 3, 5, 8, 10] 3 %define $cmp: @range(1, 10) %schema: @length(5) #integer*($cmp) #array [1, 3, 5, 8, 10] In the above table, all three rows have identical validation constraints for the input JSON array. This demonstrates that when dealing with simple and primitive nested values in a composite JSON construct, preferring the nested data types and functions is more convenient due to their simplicity and conciseness. However, in cases where the nested values are complex and composite, the schema component syntax becomes more suitable. The following example illustrates how the component syntax can be used to validate elements of a JSON array that are not as straightforward as the previous examples: %define $article: { \"id\": @range(1, 100) #integer, \"title\": @length(10, 100) #string, \"preview\": @length(30, 1000) #string, \"tags\": @length*(3, 30) @length(1, 5) #string* #array } #object %schema: @length(1, 10) #object*($article) #array In practical scenarios, JSON arrays often hold multiple composite JSON constructs as elements, typically sharing a recurring pattern and structure similar to the example above. To facilitate the validation of such elements, using schema components is highly effective. By defining a reusable schema component, one can improve readability, conciseness, and organization of the Schema document with such recurring structures. For instance, consider the following example of a JSON document which is valid against the Schema example above: [ { \"id\": 1, \"title\": \"Getting Started\", \"preview\": \"This guide will show you through the essential steps to quickly...\", \"tags\": [\"JSON\", \"Json Schema\", \"Quick Start\"] }, { \"id\": 2, \"title\": \"Validation Syntax\", \"preview\": \"A JSON document is a structured data format used for the exchange...\", \"tags\": [\"JSON\", \"Json Schema\", \"Validation Syntax\"] }, { \"id\": 3, \"title\": \"Constraint Functions\", \"preview\": \"This document serves as a brief overview, providing key insights into...\", \"tags\": [\"JSON\", \"Json Schema\", \"Constraint Functions\"] } ]"
  },
  "articles/datatypes.html": {
    "href": "articles/datatypes.html",
    "title": "Constraint Data Types | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } Constraint Data Types Data types play a pivotal role in validating JSON data for compliance with the schema. Essentially, data types determine the kind of data that a JSON element or value can contain. This mechanism serves as a fundamental process in maintaining the accuracy, consistency, and integrity of JSON document and its structure throughout the system, where data quality and reliability are vital. In the schema document, data types are denoted by the # prefix. Here is an outline of all data types, including their subtypes, used in the schema document to validate a JSON document. When using multiple data types for validation, it indicates that the JSON value is considered valid if it complies with any of the specified alternative data types. All of these data types and their subtypes offer the flexibility of selecting the most appropriate type based on requirements. #any   #primitive     #string       #datetime       #date    #time   #number       #integer    #float    #double   #boolean   #null  #composite   #array  #object The Any Data Type This data type accepts any valid JSON value that conforms to the JSON standard. It is the least restrictive data type and serves as the parent type for all other data types defined in this schema, each of which imposes more specific constraints. Here is the specification of JSON document containing rules of all valid JSON values. Following is the syntax for specifying this data type: #any The Primitive Data Type This serves as the foundational data type for all non-composite or primitive JSON values. While it is not intended for direct use in a schema, it organizes common functionalities across other sub-data types. Nevertheless, it remains valid for use, as illustrated by the following syntax: #primitive The Composite Data Type As the parent data type for two kinds of composite JSON values, namely arrays and objects, this composite type consists of zero or more JSON values. It is not designed to be used in a schema but rather the organization of shared functionalities among other sub-data types. Despite this, it is still valid for use, demonstrated by the following syntax: #composite The Array Data Type This data type represents the JSON array type and accepts any JSON array specified by the JSON standard. The specification document for JSON provides details about the various syntax and forms of JSON arrays. Below is the syntax for specifying this data type: #array The Object Data Type This data type represents the JSON object type and accepts any JSON object specified by the JSON standard. The specification document for JSON provides details about the different syntax and forms of JSON objects. Following is the syntax for specifying this data type: #object The String Data Type This is one of the most commonly used data types in a JSON document, designed to accept any JSON string as specified by the JSON standard. The syntax for specifying this data type is as follows: #string The Date Time Data Type The date-time data type serves as the parent data type for both date and time types. It is a subtype of JSON string type and thus formatted as per the JSON string specification. It is not intended to be used directly in a schema, but it provides common functionality for both date and time types. #datetime The Date Data Type The date data type accepts a string representation of a date, conforming to the ISO 8601 standard (date part only). This is the default configuration, which can be modified using the directive described here. It is a subtype of date-time type and thus also formatted as per the JSON string specification. Detailed explanations of the ISO 8601 standard can be found in this document. Furthermore, you can refer to this document for a detailed description of the date pattern associated with this data type. To define this data type in schema, use the following syntax: #date The Time Data Type The time data type accepts a string representation of a time (including both date and time parts), in accordance with the ISO 8601 standard. This default configuration can be modified using the directive described here. Similar to the date data type, it is a subtype of date-time data type and thus also formatted as per the JSON string specification. Here is the ISO 8601 standard document, which contains detailed explanations. Furthermore, you can refer to this document for a detailed description of the date-time pattern associated with this data type. To define this data type in schema, use the following syntax: #time The Number Data Type The number data type serves as the parent data type for all numeric types accommodated by the schema, including integer, floating-point, and exponent-based numbers. It accepts any JSON numerical value in accordance with the JSON standard. The syntax for specifying the number type is as follows: #number The Integer Data Type The integer data type is a subtype of the number data type that only allows integral numbers or whole numbers without any fraction and exponent and thus provides constraints for a wide range of real-world scenarios where numbers cannot involve decimal points or exponents. To specify the integer type in schema, use the following syntax: #integer The Float Data Type The float data type is also a subtype of the number data type that only accepts floating point numbers and does not allow exponent in numbers or integral numbers. This constraint is useful for various real-world applications that require numbers to be exclusively in floating-point format. To specify the float type in schema, use the following syntax: #float The Double Data Type The double data type, as a subtype of the number data type, exclusively accepts numbers with exponents. It can either be an integral number with an exponent or a floating-point number with an exponent. This constraint distinguishes it from other number formats and makes it particularly useful for handling large numbers with exponents. To specify the double type in a schema, use the following syntax: #double The Boolean Data Type The boolean data type is a binary or switch-based data type that only accepts two values, namely true and false. It is particularly useful in situations where toggling and switching are necessary. To specify the boolean type in the schema, use the following syntax: #boolean The Null Data Type The null data type serves as a special constraint within JSON schemas, facilitating the controlled use of null in place of other JSON elements or values. Typically, it is combined with other data types to permit the use of null for specific JSON elements or values. This can set constraints for scenarios in which an array without any elements and an object without any properties can either have null or only be allowed to be empty. Additionally, the @nonempty constraint functions can be employed to further control the use of empty values within a JSON document. To specify the null type in the schema, use the following syntax: #null"
  },
  "articles/datetime.html": {
    "href": "articles/datetime.html",
    "title": "Date and Time Patterns | Json Schema",
    "keywords": "Date and Time Patterns Dates and times are fundamental data types used in a wide range of data exchange scenarios. This schema offers a comprehensive set of tools for managing dates and times, including pattern-based formatting to meet the unique requirements of various systems and applications. Simultaneously, it incorporates validation processes to ensure compliance with the schema. Date and time formats are defined using date and time pattern strings. Within these pattern strings, unquoted letters ranging from 'A' to 'Z' and 'a' to 'z' serve as placeholders representing various components of a date or time string. To prevent their interpretation as patterns, text can be enclosed in single quotes ('). Additionally, two consecutive single quotes ('') are used to represent a literal single quote within the string. Any characters outside of these uppercase and lowercase letters, as well as the text enclosed in single quotes, are not interpreted and are matched against the input string during validation. Below, you will find a list of pattern letters and strings that are defined for date and time patterns. Please note that any characters within the 'A' to 'Z' and 'a' to 'z' range are reserved and should not be directly included in the pattern string. SN Pattern Description Example 1 G Era period designator AD 2 YYYY Four digit year number 1970 3 YY Two digit year number 70 4 MM Month number in year (2 digit form) 01 5 MMMM Full name of month January 6 MMM Short name of month Jan 7 M Month number in year (1-2 digit form) 1; 01 8 DDDD Full name of day in week Monday 9 DDD Short name of day in week Mon 10 DD Day in month (2 digit form) 01 11 D Day in month (1-2 digit form) 1; 01 12 t AM/PM designator AM; PM 13 hh Hour in day (2 digit form) 01; 12 14 h Hour in day (1-2 digit form) 1; 01 15 mm Minute in hour (2 digit form) 01; 20 16 m Minute in hour (1-2 digit form) 1; 01 17 ss Second in minute (2 digit form) 01; 30 18 s Second in minute (1-2 digit form) 1; 01 19 f Tenths of a second 1 20 ff Hundredths of a second 11 21 fff Milliseconds of a second 111 22 ffff Ten thousandths of a second 1111 23 fffff Hundred thousandths of a second 11111 24 ffffff Millionths of a second 111111 25 F Fraction of a second upto 6 digits 1; 111; 111111 26 Z Time zone hours only offset +06; -05; Z 27 ZZ Time zone hours and minutes offset +09:30; 03:30; Z 28 ZZZ Time zone hours and minutes offset +0930; 0330; Z The pattern components listed above can be combined to create comprehensive and customized date and time patterns to accommodate all system and user requirements. The following table illustrates some examples of how different date-time pattern components can be combined. SN Usage Combined Pattern Example 1 #date YYYY-MM-DD 2023-09-01 2 #time YYYY-MM-DD'T'hh:mm:ss.FZZ 2023-09-01T14:35:10.111+06:00 3 @date MMMM DD, YYYY G January 01, 1980 AD 4 @date DDDD, D MMMM YYYY Tuesday, 11 July 2023 5 @time YYYY.MM.DD hh.mm.ss t 1980.11.21 10.30.50 pm 6 @time DDD, D MMM YY hh:mm:ss ZZ Sun, 4 Jul 99 12:08:56 -06:00 7 @time hh:mm:ss t ZZ 03:11:30 AM +06:00 The first pattern in the table above adheres to the ISO 8601 date format and is used to validate the #date data type within the schema. The second pattern in the table follows the ISO 8601 format for date and time, validating the #time data type in the schema. Instead of explicitly specifying these patterns in the @date or @time functions, a more concise approach is to directly utilize the #date or #time type within the schema. Detailed explanations regarding the date and time format of the ISO 8601 standard are available in this document. When the AM/PM designator is included in the date and time pattern, the presence of any hour format specifier indicates that the time is in the 12-hour clock format. Conversely, when the AM/PM designator is omitted, the presence of any hour format specifier indicates that the time is in the 24-hour clock format."
  },
  "articles/directives.html": {
    "href": "articles/directives.html",
    "title": "Validation Directives | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } Validation Directives Directives serve as special instructions or commands for the Schema and JSON parsers, interpreters, and validators. They are used to control various aspects of the validation process or to provide metadata for documentation. Additionally, they offer crucial information about Schema and JSON and provide custom validation functions to meet specific Schema validation requirements. Title Directive Within a schema, the title directive is used to provide a name, label, or a brief intent of the schema for which it is written. Besides, the title directive is optional and additional description can be supplied as multiple comments inside the schema document to provide more detail. However, this directive is only used for documentation purposes and does not have any impact in the validation process. To represent the title directive, the following example of notation can be used: %title: \"Example name or brief description\" Version Directive In a schema, the version directive is used to provide a version number of the schema which helps to keep track of updates. Although optional, the version directive is useful for documentation purposes and does not affect the validation process. The version directive can be represented using the following notation example: %version: 2023.09.11.01 Include Directive Include directive enables the addition or inclusion of a class, as defined by object-oriented programming, to a schema along with a set of methods that have specific signatures for performing custom validations. This feature extends the built-in validation capabilities of the schema. In the C# language, it is also necessary to specify the assembly name together with the class name. The example below illustrates how to utilize the include directive in C# language: %include: RelogicLabs.JsonSchema.Tests.External.ExternalFunctions, RelogicLabs.JsonSchema.Tests Pragma Directive Pragma directives provide a mechanism to modify the default settings for certain predefined parameters of the validation process. This allows you to adjust the behaviours of schema validation process as per your requirements. Ignore Undefined Properties The IgnoreUndefinedProperties pragma directive serves the purpose of instructing the validation process on how to handle JSON properties that are not explicitly defined in the schema, not even by the undefined marker or symbol. You can use this directive to specify whether such properties should be ignored during validation or if validation errors should be raised for any undefined properties in the JSON document. The default value of this directive is false, which means that by default, undefined properties in the JSON document are not ignored, and validation errors will be raised for them. For example, the following usage of this directive instructs the validation process to ignore any undefined properties in the JSON document: %pragma IgnoreUndefinedProperties: true Date Data Type Format The DateDataTypeFormat pragma directive enables you to customize the default format of the #date data type. By default, the #date data type follows the ISO 8601 standard, precisely using the format YYYY-MM-DD. Additional details on date-time patterns and formats are available here. The subsequent example illustrates the process of defining a customized date format for the #date data type: %pragma DateDataTypeFormat: \"DD-MM-YYYY\" Time Data Type Format To customize the default format of the #time data type, utilize the TimeDataTypeFormat pragma directive. By default, the #time data type follows the ISO 8601 standard, precisely in the format YYYY-MM-DD'T'hh:mm:ss.FZZ. Further information on date-time patterns and formats can be found here. The following example demonstrates how to specify a customized time format for the #time data type: %pragma TimeDataTypeFormat: \"DD-MM-YYYY hh:mm:ss\" Floating Point Tolerance The FloatingPointTolerance pragma directive allows you to define the tolerance level for relative errors in floating-point numbers during calculations and computations carried out by the validation process. By default, this directive is set to 1E-10, indicating a small tolerance. However, you have the flexibility to adjust this value to any desired number. To specify a custom tolerance value of 1E-07, you can use the following notation as an example: %pragma FloatingPointTolerance: 1E-07 Ignore Object Property Order The IgnoreObjectPropertyOrder pragma directive provides a means to enforce a specific order or sequence of JSON object properties, following the schema definition. This requirement for strict ordering is only needed in certain special cases. By default, this directive is set to true, meaning that the object property order outlined in the schema document is not mandatory. However, you can override this default by setting it to false, as shown in the following example below: %pragma IgnoreObjectPropertyOrder: false Definition / Define Directive This feature in JSON schemas allows you to define a name for a component or fragment of schema or validation rules, which can be referenced from various parts of your schema. This means that if you encounter similar validation requirements in different sections of your schema, you can conveniently refer to the named component instead of duplicating the same validation rules. By providing clear and descriptive names for these validation rules or sub-schemas, you can enhance the overall clarity and context of your schema. This clarity not only makes it easier to understand the structure and intent of the schema but also contributes to keeping your complex schema well-organized, concise, and more manageable. For more information about the schema component syntax and format, please refer to the documentation here. The name or alias of the directive is always start with $ which also refers to that they are named fragment defined elsewhere in the schema. Here is a simple example of how to use this directive: %define $product: { \"id\": @length(2, 10) @regex(\"[a-z][a-z0-9]+\") #string, \"name\": @length(5, 100) #string, \"price\": @range(0.1, 1000000), \"inStock\": #boolean } Schema Directive The schema directive serves as the starting or entry point for both the schema document and the schema validation process. It becomes mandatory when other directives are present within the document. In such cases, the schema directive explicitly designates the beginning of the schema document and defines the entry point for validation process. However, if there are no other directives used in the document, the entire document itself is automatically considered as the schema document, with the document's beginning serving as its entry point. To illustrate, here is a simple example of a schema document with schema directive: %schema: { \"user\": { \"id\": @range(1, 10000) #integer, /*username does not allow special characters*/ \"username\": @regex(\"[a-z_]{3,30}\") #string, /*currently only one role is allowed by system*/ \"role\": \"user\" #string, \"isActive\": #boolean, //user account current status \"registeredAt\": #time } }"
  },
  "articles/functions.html": {
    "href": "articles/functions.html",
    "title": "Constraint Functions | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } table th:first-of-type { min-width: 140px; } Constraint Functions This document serves as a brief overview, providing key insights into the built-in constraint functions that are part of the core schema. These functions significantly extend the scope of data and structural validation, going beyond the limits of basic data type restrictions. These functions are designed to enhance the effectiveness of schema validation, ensuring the accuracy, consistency, integrity, and compliance of the JSON data to the schema. The notation below outlines the typical structure of constraint or validation functions applicable to JSON elements or values. In this notation, Target comprises two components: the target type, which specifies the JSON value type under consideration, and the target name, which identifies the specific JSON value to which the validation or constraint function applies. The Constraint-Function refers to the name of the function responsible for the validation. Target - Constraint-Function[(Parameter-Set)] The Parameter-Set contains the parameters that control the validation process provided by the constraint function on the target JSON value. Please note that the Parameter-Set including the opening and closing parentheses are optional. The ellipsis or three dots ... after a parameter type indicates it can accept any number of arguments of that type. When using multiple validation functions, each function validates the target JSON value, and the overall validation succeeds only when every function independently deems the target JSON value as valid. Function Details Below, you will find a detailed explanation of the syntax and useful applications of each function, allowing you to gain a clear understanding of their usage. String Length #string target - @length(#integer number) Validates that the target string has the length specified by the number. If the length of the target string does not match the value specified by number, a validation error will generate. #string target - @length(#integer minimum, #integer maximum) Validates that the length of the target string satisfies the range requirement specified by the parameters. It checks that the length of the target string is equal to or greater than the minimum length specified and simultaneously less than or equal to the maximum length specified. If not, a validation error will generate. If either the parameter values for minimum or maximum are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @length function of the two variations described above, for the target data type string: Ues Cases Valid Values Invalid Values @length(4) \"ABCD\" \"AB\"; \"ABCDE\" @length(2, 4) \"AB\"; \"ABC\"; \"ABCD\" \"\"; \"A\"; \"ABCDE\" @length(2, !) \"AB\"; \"ABCDEFGH\" \"\"; \"A\" @length(!, 4) \"\"; \"A\"; \"ABC\"; \"ABCD\" \"ABCDE\"; \"ABCDEFGHI\" Array Length #array target - @length(#integer number) Validates that the target array has the length specified by the number. If the length of the target array does not match the value specified by number, a validation error will generate. #array target - @length(#integer minimum, #integer maximum) Validates that the length of the target array satisfies the range requirement specified by the parameters. It checks that the length of the target array is equal to or greater than the minimum length specified and simultaneously less than or equal to the maximum length specified. If not, a validation error will generate. If either the parameter values for minimum or maximum are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @length function of the two variations described above, for the target data type array: Ues Cases Valid Values Invalid Values @length(4) [1, 2, 3, 4] [1, 2, 3]; [1, 2, 3, 4, 5] @length(2, 4) [1, 2]; [1, 2, 3]; [1, 2, 3, 4] []; [1]; [1, 2, 3, 4, 5] @length(2, !) [1, 2]; [1, 2, 3, 4, 5] []; [1] @length(!, 4) []; [1, 2]; [1, 2, 3, 4] [1, 2, 3, 4, 5]; [1, 2, 3, 4, 5, 6] Object Length / Size #object target - @length(#integer number) Validates that the target object has the length or size specified by the number. If the length of the target object does not match the value specified by number, a validation error will generate. #object target - @length(#integer minimum, #integer maximum) Validates that the length or size of the target object satisfies the range requirement specified by the parameters. It checks that the length of the target object is equal to or greater than the minimum length specified and simultaneously less than or equal to the maximum length specified. If not, a validation error will generate. If either the parameter values for minimum or maximum are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @length function of the two variations described above, for the target data type object: Ues Cases Valid Values Invalid Values @length(4) {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4} {\"k1\":1, \"k2\":2, \"k3\":3}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4, \"k5\":5} @length(2, 4) {\"k1\":1, \"k2\":2}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4} {}; {\"k1\":1}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4, \"k5\":5} @length(2, !) {\"k1\":1, \"k2\":2}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4, \"k5\":5} {}; {\"k1\":1} @length(!, 4) {}; {\"k1\":1, \"k2\":2}; {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4} {\"k1\":1, \"k2\":2, \"k3\":3, \"k4\":4, \"k5\":5} Number Range #number target - @range(#number minimum, #number maximum) Validates that the target number satisfies the range requirement specified by the parameters. It checks that the target number is greater than or equal to the minimum number specified and simultaneously less than or equal to the maximum number specified. If not, a validation error will generate. If either the parameter values for minimum or maximum are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @range function of the two variations described above, for the target data type number: Ues Cases Valid Values Invalid Values @range(2, 4) 2; 3; 4 0; 1; -100; 100 @range(2, !) 2; 3; 4; 100 0; 1; -100 @range(!, 4) 0; 1; 4; -100 5; 10; 100 Number Minimum #number target - @minimum(#number minimum) #number target - @minimum(#number minimum, #boolean exclusive) Validates that the target number is greater than or equal to the minimum number specified as a parameter, unless the exclusive parameter flag is explicitly set to true, in which case the target number must be exclusively greater than the minimum number. Ues Cases Valid Values Invalid Values @minimum(0) 0; 1; 1000 -1; -10; -10000 @minimum(10.5) 10.5; 10.6; 1000.1 10.49; 1.0; -100.1 @minimum(0, true) 0.001; 1.01; 100.1 0; -0.01; -100.1 Number Maximum #number target - @maximum(#number maximum) #number target - @maximum(#number maximum, #boolean exclusive) Validates that the target number is less than or equal to the maximum number specified as a parameter, unless the exclusive parameter flag is explicitly set to true, in which case the target number must be exclusively less than the maximum number. Ues Cases Valid Values Invalid Values @maximum(100) 100; -100; 0 101; 1000; 10000 @maximum(10.5) 10.50; 10.49; -1000.1 10.51; 11.0; 1000.1 @maximum(0, true) -0.001; -1.01; -1000.1 0; 0.01; 100.1 Enum String and Number #string target - @enum(#string... items) #number target - @enum(#number... items) Validates that the target string or number is equal to one of the strings or numbers respectively, specified by the items parameter. If not, a validation error will generate. Array Elements #array target - @elements(#any... items) Validates that the target array contains every JSON value specified by the items parameter. If not, it generates a validation error. Object Keys #object target - @keys(#string... items) Validates that all the strings specified in the items parameter are present as keys in the target object. If any of them is missing, a validation error is generated. Object Values #object target - @values(#any... items) Validates that all the JSON values specified in the items parameter are present as values in the target object. If any of them is missing, a validation error is generated. String Regular Expression (Regex) #string target - @regex(#string pattern) Validates that the target string matches the regular expression pattern specified by the pattern parameter. The regular expression engine used here supports standard syntax from both POSIX (IEEE Portable Operating System Interface) Extended Regular Expressions and Perl-Compatible Regular Expressions (PCRE). For more details, please refer to POSIX Regular Expressions. Email Address #string target - @email Validates whether the target string represents a valid email address. It follows the SMTP protocol RFC 5322 specification for mailbox address format to identify a valid email address. In addition to conforming to this standard, it recognizes all widely used email address formats to ensure compatibility with various systems and user requirements. URL & URI Address #string target - @url(#string scheme) Validates whether the target string is a valid URL (Uniform Resource Locator) or URI (Uniform Resource Identifier) with a specific scheme provided by the scheme parameter. It follows the RFC 3986 URI Generic Syntax to determine the validity of the URL or URI. In addition to conforming to this standard, it recognizes all widely used URL and URI address formats, ensuring compatibility with a wide range of systems and user requirements. #string target - @url Validates whether the target string is a valid URL or URI with HTTP and HTTPS scheme. For more information please check the function #string target - @url(#string scheme). Phone Number #string target - @phone Validates whether the target string is a valid phone number. It follows the ITU-T E.163 and E.164 telephone number notation to determine the validity of the phone number. In addition to conforming to this standard, it recognizes all widely used national and international phone number formats, ensuring compatibility with a wide range of systems and user requirements. Date and Time #string target - @date(pattern) Validates that the target string matches the date and time pattern specified by the pattern parameter. It fully supports the ISO 8601 date and time format. Beyond this standard, it also allows custom date and time formats, ensuring compatibility with various systems and meeting diverse users and businesses requirements. This document provides a comprehensive overview of the date-time custom patterns. #string target - @time(pattern) Both the @date and @time functions support a complete range of date-time patterns, enabling the precise definition of any date and time scenario. Therefore, these functions can be used interchangeably. When the sole consideration is the date or day of the month in a year, employing the @date function is the more convenient choice. In contrast, when it becomes necessary to specify a particular time on a date, the @time function is the more appropriate option. To learn more about date-time patterns, please refer to this page. Date and Time Range #datetime target - @range(#string start, #string end) Validates that the target date-time satisfies the range requirement specified by the parameters. It checks that the target date-time is from or after the start date-time specified and simultaneously until and before the end date-time specified. If not, a validation error will generate. The start and end parameters must be the string representation of the target data type, which can either be a #date or #time type. If either the parameter values for start or end are unspecified or undefined, the undefined symbol ! can be used in place of either of these parameters. The following examples illustrate the various use cases of the @range function of the two variations described above, for the target type: Ues Cases Valid Values Invalid Values @range(\"2010-01-01\", \"2010-12-31\") 2010-01-01; 2010-06-30; 2010-12-31 2009-12-31; 2011-01-01; 2030-11-05 @range(\"2010-01-01T00:00:00.000Z\", \"2010-12-31T23:59:59.999Z\") 2010-01-01T00:00:00.000Z; 2010-12-31T23:59:59.999Z 2009-12-31T23:59:59.999Z @range(!, \"2010-12-31\") 1990-01-01; 2010-12-31 2011-01-01; 2030-11-05 @range(\"2010-01-01\", !) 2010-01-01; 2030-11-05 1990-01-01; 2009-12-31 Date and Time Start #datetime target - @start(#string reference) Validates that the target date-time starts from or finds after the specified reference date-time parameter. If the target date-time finds before the reference date-time, a validation error is triggered. The reference parameter must be the string representation of the target data type, which can either be a #date or #time type. Date and Time End #datetime target - @end(#string reference) Validates that the target date-time finds before or ends at the specified reference date-time parameter. If the target date-time finds after the reference date-time, a validation error is triggered. The reference parameter must be the string representation of the target data type, which can either be a #date or #time type. Date and Time Before #datetime target - @before(#string reference) Validates that the target date-time is exclusively before the reference date-time. If the target date-time finds on or after the reference date-time, a validation error is triggered. The reference parameter must be the string representation of the target data type, which can either be a #date or #time type. Date and Time After #datetime target - @after(#string reference) Validates that the target date-time is exclusively after the reference date-time. If the target date-time finds on or before the reference date-time, a validation error is triggered. The reference parameter must be the string representation of the target data type, which can either be a #date or #time type. Number Positive and Negative #number target - @positive #number target - @positive(#number reference) Validates that the target number is positive or positive from (or relative to) the specified reference. If the target number is zero or negative for the first definition or less than the reference for the second definition, it generates a validation error. #number target - @negative #number target - @negative(#number reference) Validates that the target number is negative or negative from (or relative to) the specified reference. If the target number is zero or positive for the first definition or greater than the reference for the second definition, it generates a validation error. Ues Cases Valid Values Invalid Values @positive 1; 5; 1000 0; -1; -1000 @negative -1; -5; -1000 0; 1; 1000 @positive(0) 0; 1; 5; 1000 -1; -5; -1000 @positive(10) 10; 100; 10000 1; 5; -1000 @negative(0) 0; -1; -5; -1000 1; 5; 1000 @negative(-10) -10; -100; -10000 0; -5; 1000 @positive(-1) -1; 0; 10000 -10; -100; -1000 @negative(1) 1; 0; -10000 10; 100; 1000 String Not Empty #string target - @nonempty Validates that the target string is not empty. If the target string is empty, it generates a validation error. Array Not Empty #array target - @nonempty Validates that the target array is not empty. If the target array is empty, it generates a validation error. Object Not Empty #object target - @nonempty Validates that the target object is not empty. If the target object is empty, it generates a validation error."
  },
  "articles/quickstart.html": {
    "href": "articles/quickstart.html",
    "title": "Getting Started | Json Schema",
    "keywords": "Getting Started This guide will walk you through the essential steps to quickly get up and running with the New JSON Schema library. It is also assumed a modest familiarity with the C# language, .NET SDK, and .NET CLI (command-line interface), including basic familiarity with NuGet packages. NuGet Library Package To get started, launch your preferred IDE (such as Visual Studio, JetBrains Rider, or VS Code) and open the C# project where you intend to include this library package. Within your IDE, navigate to the NuGet package manager and search for the package by the name 'RelogicLabs.JsonSchema'. Subsequently, proceed to add or install the package to your project. Alternatively, you can use the .NET CLI to add the package to your project. Simply run the following command, replacing 1.x.x with either the latest version or your preferred version: dotnet add package RelogicLabs.JsonSchema --version 1.x.x To verify the successful integration of the library into your project, you may manually inspect your project file, typically named .csproj, using a text editor, and search for the following XML snippet within the file: <ItemGroup> <PackageReference Include=\"RelogicLabs.JsonSchema\" Version=\"1.x.x\" /> </ItemGroup> For additional information regarding this library package, you can visit the NuGet package repository page of this library here. Write a Sample to Test With all the necessary components in place, you are now ready to create a sample schema and validate a corresponding JSON against the schema. The subsequent example presents a C# class featuring a method designed for validating a sample JSON based on a provided schema. If you are working with C# 11 or above, you can enhance the code further by utilizing new language features like raw string literals, file scoped namespaces and others. using RelogicLabs.JsonSchema; namespace CSharpApplication { public class SampleSchema { public bool CheckIsValid() { var schema = @\"%title: \"\"User Profile Response\"\" %version: 1.0.0 %schema: { \"\"user\"\": { \"\"id\"\": @range(1, 10000) #integer, /*username does not allow special characters*/ \"\"username\"\": @regex(\"\"[a-z_]{3,30}\"\") #string, /*currently only one role is allowed by system*/ \"\"role\"\": \"\"user\"\" #string, \"\"isActive\"\": #boolean, //user account current status \"\"registeredAt\"\": #time, \"\"profile\"\": { \"\"firstName\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string, \"\"lastName\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string, \"\"dateOfBirth\"\": #date, \"\"age\"\": @range(18, 130) #integer, \"\"email\"\": @email #string, \"\"pictureURL\"\": @url #string, \"\"address\"\": { \"\"street\"\": @length(10, 200) #string, \"\"city\"\": @length(3, 50) #string, \"\"country\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string } #object #null } } }\"; var json = @\"{ \"\"user\"\": { \"\"id\"\": 9999, \"\"username\"\": \"\"johndoe\"\", \"\"role\"\": \"\"user\"\", \"\"isActive\"\": true, \"\"registeredAt\"\": \"\"2023-09-06T15:10:30.639Z\"\", \"\"profile\"\": { \"\"firstName\"\": \"\"John\"\", \"\"lastName\"\": \"\"Doe\"\", \"\"dateOfBirth\"\": \"\"1993-06-17\"\", \"\"age\"\": 30, \"\"email\"\": \"\"john.doe@example.com\"\", \"\"pictureURL\"\": \"\"https://example.com/picture.jpg\"\", \"\"address\"\": { \"\"street\"\": \"\"123 Some St\"\", \"\"city\"\": \"\"Some town\"\", \"\"country\"\": \"\"Some Country\"\" } } } }\"; JsonSchema jsonSchema = new(schema); return jsonSchema.IsValid(json); } } } Create Validation Errors Let's intentionally introduce a few errors by modifying the previous JSON document and then examine the validation results. To begin, we'll alter the id within the user object to a string type and observe the outcome. Additionally, we'll modify the username by inserting a space into its value, thus creating an invalid username. Below is the revised JSON representation, now containing these purposeful errors. { \"user\": { \"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"profile\": { \"firstName\": \"John\", \"lastName\": \"Doe\", \"age\": 30, \"email\": \"john.doe@example.com\", \"pictureURL\": \"https://example.com/picture.jpg\", \"address\": { \"street\": \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\" } } } } To achieve the desired outcome, please make the following changes to the preceding code. Specifically, ensure that any schema validation errors are displayed in the console. The modified code snippet that invokes the WriteError method to display the errors if validation fails is as follows: ... JsonSchema jsonSchema = new(schema); if(!jsonSchema.IsValid(json)) jsonSchema.WriteError(); ... Here is the error as displayed in the console. More specific errors will be listed first, followed by more general errors. Consequently, the specific errors will precisely pinpoint the issues within the JSON document, while the generic errors will provide contextual information about where the errors occurred. Schema (Line: 6:47) Json (Line: 3:30) [DTYP04]: Data type mismatch. Data type #integer is expected but found #string inferred by \"not number\". Schema (Line: 6:30) Json (Line: 3:30) [FUNC03]: Function @range(1, 10000) is incompatible with the target data type. Applying to a supported data type such as #number is expected but applied to an unsupported data type #string of \"not number\". Schema (Line: 8:36) Json (Line: 4:36) [REGX01]: Regex pattern does not match. String of pattern \"[a-z_]{3,30}\" is expected but found \"john doe\" that mismatches with pattern. Schema (Line: 5:28) Json (Line: 2:28) [VALD01]: Validation failed. A valid value of {\"id\": @range(1, 10000) #integer, \"username\": @regex(\"[a-z_]{3,30}\") #string, \"role\": \"user\" #string, \"isActive\": #boolean, \"register...ing, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string} #object #null}} is expected but found {\"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"registeredAt\": \"2023-09-06T15:10:30.639Z\", \"profile\":...: \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\"}}}. Schema (Line: 4:16) Json (Line: 1:0) [VALD01]: Validation failed. A valid value of {\"user\": {\"id\": @range(1, 10000) #integer, \"username\": @regex(\"[a-z_]{3,30}\") #string, \"role\": \"user\" #string, \"isActive\": #boolean, ...ng, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string} #object #null}}} is expected but found {\"user\": {\"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"registeredAt\": \"2023-09-06T15:10:30.639Z\", \"... \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\"}}}}. Assertion for Validation To utilize this library for test automation and API testing, you can use the following alternative code snippet to perform assertions on input JSON against a specified schema. For instance, let's examine how to assert the JSON, which has been intentionally altered to introduce some errors, against the aforementioned schema. The following demonstrates the adjusted code for asserting the JSON with errors: ... try { JsonAssert.IsValid(schema, json); } catch(Exception e) { Console.Error.WriteLine(e); } ... The following presents the printed stack trace for the preceding example. It's important to note that when using JsonAssert, it throws an exception upon encountering the first error, thus preventing the continuation of processing the rest of the schema: RelogicLabs.JsonSchema.Exceptions.JsonSchemaException: DTYP04: Data type mismatch Expected (Schema Line: 6:47): data type #integer Actual (Json Line: 3:30): found #string inferred by \"not number\" at RelogicLabs.JsonSchema.Tree.ExceptionRegistry.FailWith(Exception exception) at RelogicLabs.JsonSchema.Types.JValidator.MatchDataType(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JObject.Match(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JObject.Match(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JRoot.Match(JNode node) at RelogicLabs.JsonSchema.Tree.SchemaTree.Match(IDataTree dataTree) at RelogicLabs.JsonSchema.JsonAssert.IsValid(String json) at RelogicLabs.JsonSchema.JsonAssert.IsValid(String schema, String json) at CSharpApplication.SampleSchema.CheckIsValid() in /SampleSchema.cs:line 62 For more information about the schema syntax format and library functionalities, please refer to the reference documentation here."
  },
  "articles/sourcebuild.html": {
    "href": "articles/sourcebuild.html",
    "title": "Build from Source Code | Json Schema",
    "keywords": "Build from Source Code This comprehensive guide illustrates the procedures for retrieving source code from a GitHub repository, compiling the project source code into a library, and seamlessly integrating the compiled library into your project. It is essential to have a foundational understanding of the C# language, as well as a modest level of familiarity with the .NET SDK and CLI. Build the Library To get started, clone the project from the following URL using your preferred Git client (command line or GUI). You can open a terminal and enter the following Git clone command as shown below: git clone https://github.com/relogiclabs/JsonSchema-DotNet.git Next, use .NET build command dotnet build to build the project and Retrieve the DLL file, RelogicLabs.JsonSchema.dll from the bin folder. Add the Library to Your Project To integrate the library with your project, you can create a libs folder within your project directory and place the retrieved DLL file into the designated folder. Alternatively, if your IDE supports adding references, you can conveniently select the DLL from the libs folder. Alternatively, you can manually modify your project file .csproj using a text editor and include the following XML snippet: <ItemGroup> <Reference Include=\"RelogicLabs.JsonSchema\"> <HintPath>libs\\RelogicLabs.JsonSchema.dll</HintPath> </Reference> </ItemGroup> Additionally, this project has a dependency on ANTLR runtime, which you can integrate by executing the following command: dotnet add package Antlr4.Runtime.Standard --version 4.13.1 Write a Sample to Test With all the necessary components in place, you are now ready to create a sample schema and validate a corresponding JSON against the schema. The subsequent example presents a C# class featuring a method designed for validating a sample JSON based on a provided schema. If you are working with C# 11 or above, you can enhance the code further by utilizing new C# language features like raw string literals, file scoped namespaces and others. using RelogicLabs.JsonSchema; namespace CSharpApplication { public class SampleSchema { public bool CheckIsValid() { var schema = @\"%title: \"\"User Profile Response\"\" %version: 1.0.0 %schema: { \"\"user\"\": { \"\"id\"\": @range(1, 10000) #integer, /*username does not allow special characters*/ \"\"username\"\": @regex(\"\"[a-z_]{3,30}\"\") #string, /*currently only one role is allowed by system*/ \"\"role\"\": \"\"user\"\" #string, \"\"isActive\"\": #boolean, //user account current status \"\"registeredAt\"\": #time, \"\"profile\"\": { \"\"firstName\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string, \"\"lastName\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string, \"\"dateOfBirth\"\": #date, \"\"age\"\": @range(18, 130) #integer, \"\"email\"\": @email #string, \"\"pictureURL\"\": @url #string, \"\"address\"\": { \"\"street\"\": @length(10, 200) #string, \"\"city\"\": @length(3, 50) #string, \"\"country\"\": @regex(\"\"[A-Za-z ]{3,50}\"\") #string } #object #null } } }\"; var json = @\"{ \"\"user\"\": { \"\"id\"\": 9999, \"\"username\"\": \"\"johndoe\"\", \"\"role\"\": \"\"user\"\", \"\"isActive\"\": true, \"\"registeredAt\"\": \"\"2023-09-06T15:10:30.639Z\"\", \"\"profile\"\": { \"\"firstName\"\": \"\"John\"\", \"\"lastName\"\": \"\"Doe\"\", \"\"dateOfBirth\"\": \"\"1993-06-17\"\", \"\"age\"\": 30, \"\"email\"\": \"\"john.doe@example.com\"\", \"\"pictureURL\"\": \"\"https://example.com/picture.jpg\"\", \"\"address\"\": { \"\"street\"\": \"\"123 Some St\"\", \"\"city\"\": \"\"Some town\"\", \"\"country\"\": \"\"Some Country\"\" } } } }\"; JsonSchema jsonSchema = new(schema); return jsonSchema.IsValid(json); } } } Create Validation Errors Let's intentionally introduce a few errors by modifying the previous JSON document and then examine the validation results. To begin, we'll alter the id within the user object to a string type and observe the outcome. Additionally, we'll modify the username by inserting a space into its value, thus creating an invalid username. Below is the revised JSON representation, now containing these purposeful errors. { \"user\": { \"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"profile\": { \"firstName\": \"John\", \"lastName\": \"Doe\", \"age\": 30, \"email\": \"john.doe@example.com\", \"pictureURL\": \"https://example.com/picture.jpg\", \"address\": { \"street\": \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\" } } } } To achieve the desired outcome, please make the following changes to the preceding code. Specifically, ensure that any schema validation errors are displayed in the console. The modified code snippet that invokes the WriteError method to display the errors if validation fails is as follows: ... JsonSchema jsonSchema = new(schema); if(!jsonSchema.IsValid(json)) jsonSchema.WriteError(); ... Here is the error as displayed in the console. More specific errors will be listed first, followed by more general errors. Consequently, the specific errors will precisely pinpoint the issues within the JSON document, while the generic errors will provide contextual information about where the errors occurred. Schema (Line: 6:47) Json (Line: 3:30) [DTYP04]: Data type mismatch. Data type #integer is expected but found #string inferred by \"not number\". Schema (Line: 6:30) Json (Line: 3:30) [FUNC03]: Function @range(1, 10000) is incompatible with the target data type. Applying to a supported data type such as #number is expected but applied to an unsupported data type #string of \"not number\". Schema (Line: 8:36) Json (Line: 4:36) [REGX01]: Regex pattern does not match. String of pattern \"[a-z_]{3,30}\" is expected but found \"john doe\" that mismatches with pattern. Schema (Line: 5:28) Json (Line: 2:28) [VALD01]: Validation failed. A valid value of {\"id\": @range(1, 10000) #integer, \"username\": @regex(\"[a-z_]{3,30}\") #string, \"role\": \"user\" #string, \"isActive\": #boolean, \"register...ing, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string} #object #null}} is expected but found {\"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"registeredAt\": \"2023-09-06T15:10:30.639Z\", \"profile\":...: \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\"}}}. Schema (Line: 4:16) Json (Line: 1:0) [VALD01]: Validation failed. A valid value of {\"user\": {\"id\": @range(1, 10000) #integer, \"username\": @regex(\"[a-z_]{3,30}\") #string, \"role\": \"user\" #string, \"isActive\": #boolean, ...ng, \"country\": @regex(\"[A-Za-z ]{3,50}\") #string} #object #null}}} is expected but found {\"user\": {\"id\": \"not number\", \"username\": \"john doe\", \"role\": \"user\", \"isActive\": true, \"registeredAt\": \"2023-09-06T15:10:30.639Z\", \"... \"123 Some St\", \"city\": \"Some town\", \"country\": \"Some Country\"}}}}. Assertion for Validation To utilize this library for test automation and API testing, you can use the following alternative code snippet to perform assertions on input JSON against a specified schema. For instance, let's examine how to assert the JSON, which has been intentionally altered to introduce some errors, against the aforementioned schema. The following demonstrates the adjusted code for asserting the JSON with errors: ... try { JsonAssert.IsValid(schema, json); } catch(Exception e) { Console.Error.WriteLine(e); } ... The following presents the printed stack trace for the preceding example. It's important to note that when using JsonAssert, it throws an exception upon encountering the first error, thus preventing the continuation of processing the rest of the schema: RelogicLabs.JsonSchema.Exceptions.JsonSchemaException: DTYP04: Data type mismatch Expected (Schema Line: 6:47): data type #integer Actual (Json Line: 3:30): found #string inferred by \"not number\" at RelogicLabs.JsonSchema.Tree.ExceptionRegistry.FailWith(Exception exception) at RelogicLabs.JsonSchema.Types.JValidator.MatchDataType(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JObject.Match(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JObject.Match(JNode node) at RelogicLabs.JsonSchema.Types.JValidator.Match(JNode node) at RelogicLabs.JsonSchema.Types.JRoot.Match(JNode node) at RelogicLabs.JsonSchema.Tree.SchemaTree.Match(IDataTree dataTree) at RelogicLabs.JsonSchema.JsonAssert.IsValid(String json) at RelogicLabs.JsonSchema.JsonAssert.IsValid(String schema, String json) at CSharpApplication.SampleSchema.CheckIsValid() in /SampleSchema.cs:line 62 For more information about the schema syntax format and library functionalities, please refer to the reference documentation here."
  },
  "articles/specification.html": {
    "href": "articles/specification.html",
    "title": "Specification | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } Specification New JSON Schema is a vocabulary that allows you to describe the structure and constraints of JSON documents. It provides a way to define rules for validating the data in a JSON document. With JSON Schema, you can ensure that your JSON data follows a specific format and adheres to certain rules. Grammar The New JSON Schema grammar is introduced through a notation similar to what is known as the McKeeman form grammar notation, which is a simplified version of the Backus-Naur form and Extended BackusNaur form. This form minimizes the usage of complex structures of meta-characters, making the grammar highly readable and easy to understand without requiring extensive prior knowledge of grammar syntax. Moreover, inside the grammar whitespace defining rules are ignored to make it clear and concise. schema schema-header-opt defines-opt schema-core defines-opt validator schema-header-opt title-opt version-opt includes-opt pragmas-opt title-opt '' '%title' ':' string version-opt '' '%version' ':' version-digits version-digits digits digits '.' version-digits includes-opt '' includes includes include includes include '%include' ':' class-identifier class-identifier identifier identifier '.' class-identifier pragmas-opt '' pragmas pragmas pragma pragmas pragma '%pragma' identifier ':' primitive defines-opt '' defines defines define defines define '%define' alias-name ':' validator-main alias-name '$' identifier schema-core '%schema' ':' validator validator validator-main alias-name validator-main value-opt functions-opt datatypes-opt receivers-opt this-opt value-opt '' value value primitive object array functions-opt '' functions functions function functions function function-name function-args-opt function-name '@' identifier '@' identifier '*' function-args-opt '' '(' ')' '(' function-args ')' function-args function-arg function-arg ',' function-args function-arg value receiver datatypes-opt '' datatypes datatypes datatype datatypes datatype datatype-name datatype-arg-opt datatype-name '#' alphas '#' alphas '*' alphas alpha alphas datatype-arg-opt '' '(' alias-name ')' receivers-opt '' receivers receivers receiver receivers receiver '&' identifier this-opt '' '?' object '{' '}' '{' properties '}' properties property property ',' properties property string ':' validator array '[' ']' '[' elements ']' elements validator validator ',' elements primitive string number undefined 'true' 'false' 'null' undefined '!' identifier alpha alpha alpha-numerics alpha-numerics alpha-numeric alpha-numerics alpha-numeric alpha '0' . '9' alpha 'A' . 'Z' 'a' . 'z' '_' string '\"' characters '\"' characters '' character characters character '0020' . '10FFFF' - '\"' - '\\' '\\' escape escape '\"' '\\' '/' 'b' 'f' 'n' 'r' 't' 'u' hex hex hex hex hex digit 'A' . 'F' 'a' . 'f' number integer float double integer positive-integer negative-integer float integer fraction fraction '.' digits double integer fraction-opt exponent fraction-opt '' '.' digits exponent 'E' sign-opt digits 'e' sign-opt digits sign-opt '' '+' '-' positive-integer digit one-to-nine digits negative-integer '-' digit '-' one-to-nine digits digits digit digit digits digit '0' one-to-nine one-to-nine '1' . '9' To explore more about McKeeman form grammar notation and standard JSON document grammar in McKeeman form notation, please visit this page. The resource offers valuable information regarding JSON specification and implementations in different programming languages."
  },
  "articles/validation.html": {
    "href": "articles/validation.html",
    "title": "Validation Syntax | Json Schema",
    "keywords": "pre code { font-size: 1.1em; } Validation Syntax A JSON document is a structured data format used for the exchange of information between applications. It primarily consists of two types of values: composite values and non-composite values, the latter also referred to as primitive values. Composite values in a JSON document act as containers. They can hold zero or more composite or non-composite primitive values. These composite values provide the structural framework for organizing data hierarchically within JSON documents. There are two types of composite values allowed in JSON documents: Arrays and Objects. Conversely, Non-composite values are the atomic data elements in a JSON document. They cannot contain other values within them. There are four types of primitive values supported by JSON specification: Strings, Numbers, Booleans, and Nulls. Validation Format A JSON Schema ensures the correctness and consistency of JSON documents, and it also defines the structure and constraints that a JSON document must conform to. It specifies how both composite and non-composite values should be organized and validated the input document based on the rules specified in the schema document. Thus, a key element of JSON Schema is the validation rule syntax, which provides the required instructions for the validation process. A validation rule is typically expressed using the following notations: 1. [Value] [Function-Set] [DataType-Set] [Receiver-Set] [Optional] 2. [Undefined] [Optional] SN Component Example 1 Value 10; \"string\"; [10, 20, 30]; { \"key1\": \"value1\" } 2 Function-Set @range(1, 10); @length(5, 50) @regex(\"[A-Za-z]+\") 3 DataType-Set #string; #object #null; #number* #array 4 Receiver-Set &receiver; &anyName; &anyName123 5 Value Optional 10 ?; \"string\" ?; [10, 20, 30] ? 6 Function-Set Optional @range(1, 10) ?; @length(5, 50) ? 7 DataType-Set Optional #string ?; #integer ?; #array ? 8 Function-Set DataType-Set @range(1, 10) #integer; @length(5, 10) #string 9 Function-Set DataType-Set Optional @range(1, 10) #integer ?; @length(5, 10) #string ? 10 Value Function-Set DataType-Set Receiver-Set Optional 10 @range(1, 100) #integer &receiver ? 11 Undefined ! 12 Undefined Optional ! ? The syntax used in the 10th row of the table is valid, but not common in real-world scenarios. The constraint function and data type provide redundant validations, considering the validation for value is succeeded. It is generally recommended to specify the data type in all cases except in the previous scenario. Even though the functions may perform precise validations, they are typically designed to accept a broader range of data types. Therefore, specifying the data type not only makes the schema more unambiguous for readers, but also generates clear validation errors if the expected type of value is not received from the input document. For instance, the @range function is defined for all types of numeric input as well as dates and times. If you only accept integers for a particular field, the @range function without #integer data type cannot ensure this requirement. Now, let's explore the components of this notation and their functionalities. In the context of the validation rule, Value refers to a specific input JSON value of the document. This value can be either a composite value (e.g., an object or an array) or a primitive value (e.g., a string or a number). The inclusion of Value in the validation rule is optional, meaning that you can choose whether or not to specify a particular JSON value for validation. However, when Value is present in the rule, it serves as a requirement, implying that the specified JSON value must match with the input JSON value of the document for the validation to succeed. If it does not match with the input value, the validation will fail. The Function-Set is an optional part of the validation rule that can contain one or more function constraints. Function constraints are restrictions or conditions that validate the input JSON value. These functions can be of two types based on their application: Direct functions are applied directly to the target value itself for which the validation rule is defined. Nested functions are applied to the nested values or items within the target value. They are applicable and valid only if the target value is a composite JSON value. An asterisk * is used after the function name to indicate that the constraint function is applied to the nested values. The validation of the Function-Set as a whole is considered successful only if each function constraint within it succeeds, regardless of its type and application mode. SN Function Example Valid Json Invalid Json 1 @range(1, 10) 5; 8; 10 -1; 0; 11 2 @range*(1, 10) [1, 3]; [2, 4, 6, 8, 10] [-1, 0, 5, 11] 3 @length(1, 15) \"lorem\"; \"lorem ipsum\" \"\"; \"lorem ipsum dolor\" 4 @length*(1, 15) [\"lorem\", \"lorem ipsum\"] [\"lorem\", \"lorem ipsum dolor\"] Similar to the Function-Set, the Datatype-Set is also an optional part of the validation rule and can contain one or more data type constraints. Data type constraints specify the expected data types that validate the input JSON value itself or its nested components, depending on whether the value is composite or primitive and whether its application mode is direct or nested. As like function constraints data types can be of two types based on their application: Direct data types are applied directly to the target value itself for which the validation rule is defined. Nested data type applied to the nested values or items within the target value. They are applicable and valid only if the target value is a composite JSON value. An asterisk * is used after the data type name to indicate that the data type is applied to the nested values. Validation of the Datatype-Set is deemed successful if validation is successful for one of the direct (type 1) data types and one of the nested (type 2) data types. This becomes particularly relevant in several real-world scenarios including those where a composite target value, such as an array or object, is also allowed to be null. SN Data Type Example Valid Json Invalid Json 1 #integer 5; 8; 10 10.5; 1E-08 2 #integer* #array [1, 3]; [2, 4, 6, 8, 10] [10, 10.5, 1E-08]; 10; null 3 #string \"lorem\"; \"lorem ipsum\" 100.5; [\"a\", \"b\"]; null 4 #string* #array [\"lorem\", \"lorem ipsum\"] [10, \"lorem\"]; \"lorem\"; null 5 #integer #float 5, 10.5, 1000 1E-08; \"lorem\"; false; null 6 #array #null [10, 20, 30]; null 10; 100.5; \"lorem\" 7 #integer* #float* #array [10, 10.5, 100] [10, \"lorem\", false, null] When defining nested types for values or elements for a composite type, it is good practice to also define the direct type (eg. #array and #object) that not only makes the schema more convenient for readers but also generates more straightforward validation errors if they occur, but it is optional. Moreover, each nested value must belong to one of the nested types specified in a validation rule. The Receiver-Set is also an optional part of the validation rule, and it can consist of one or more receivers. A receiver is identified by its name always prefixed by & and can receive or store the input JSON values of that position. A validation function can accept receivers and validate input based on the received values of the receivers. Moreover, one receiver can be used in multiple validation rules and one validation rule can contain multiple receivers. This flexibility facilitates the organization and utilization of receivers in a more coherent and readable manner in a schema. Depending on its position a receiver can receive zero or more JSON input values. For instance, if a receiver is placed inside a common element section of an array, it will receive zero value if the array is empty and many values if it contains many elements. The Optional marker, denoted as ?, specifies that the presence of the target value is optional within the input JSON document. When Optional is specified, it indicates that the target value may or may not be present. If it is absent, no validation is performed for that specific target value, and the JSON document is considered valid. However, if the target value is present, the validation rule must succeed for the document to be considered valid and conform to the Schema. Failure to meet the validation rule renders the JSON document invalid. The absence of the Optional specifier requires the target JSON value to be present in the input JSON document for validation to succeed. In instances where no validation rule (or no segments of the validation rule) is explicitly defined for a target input JSON value, the use of the undefined marker ! signifies that any valid JSON value is acceptable for the target. This allows more flexibility in JSON data validation for specific cases."
  },
  "index.html": {
    "href": "index.html",
    "title": "Introduction | Json Schema",
    "keywords": "Introduction JSON, short for JavaScript Object Notation, is one of the most widely used data exchange formats that are both user-friendly and machine-readable. New JSON Schema is a practical tool for defining and validating the structure of JSON documents. It allows you to specify the expected format, data types, and constraints of JSON data. The following guides offer comprehensive details about the New JSON Schema. This document provides a list of links, each corresponding to a specific detail document available in this project. Getting Started & Installation Validation Syntax & Format Validation Directives & Pragmas Schema Specification & Grammar Data Types & Validation Functions & Validation Date & Time Patterns Reusable Components of Validation Build from Source Code API Reference Documentation GitHub Source Code Repository"
  }
}